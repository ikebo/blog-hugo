---
doc_type: weread-highlights-reviews
bookId: "840978"
author: 凯S.霍斯特曼
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/978/840978/t7_840978.jpg
reviewCount: 0
noteCount: 93
readingStatus: 在读
progress: 99%
totalReadDay: 24
readingTime: 9小时1分钟
readingDate: 2022-05-24
isbn: 9787111547426
lastReadDate: 2022-11-29

---
# 元数据
> [!abstract] Java核心技术·卷Ⅰ：基础知识（原书第10版）
> - ![ Java核心技术·卷Ⅰ：基础知识（原书第10版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/978/840978/t7_840978.jpg)
> - 书名： Java核心技术·卷Ⅰ：基础知识（原书第10版）
> - 作者： 凯S.霍斯特曼
> - 简介： 本书是《Java核心技术》第10版的卷Ⅰ。自《Java核心技术》出版以来，每个新版本都尽可能快地跟上Java开发工具箱发展的步伐，而且每一版都重新改写了部分内容，以便适应Java的最新特性。在这一版中，已经反映了Java标准版（Java SE 8）的特性。与前几版一样，本版仍然将读者群定位在那些打算将Java应用到实际工程项目中的程序设计人员。本书假设读者是一名具有程序设计语言（除Java之外）坚实背景知识的程序设计人员，并且不希望书中充斥着玩具式的示例（诸如，烤面包机、动物园的动物或神经质的跳动文本）。这些内容绝对不会在本书中出现。本书的目标是让读者充分理解书中介绍的Java语言及Java类库的相关特性，而不会产生任何误解。在本书中，我们选用大量的示例代码演示所讨论的每一个语言特性和类库特性。我们有意使用简单的示例程序以突出重点，然而，其中的大部分既不是赝品也没有偷工减料。它们将成为读者自己编写代码的良好开端。
> - 出版时间 2016-09-01 00:00:00
> - ISBN： 9787111547426
> - 分类： 计算机-计算机综合
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/80a32bc05cd51280a170717

# 高亮划线

### 3.1 一个简单的Java应用程序

> 📌 char类型原本用于表示单个字符。 
> ⏱ 2022-10-31 13:11:35 ^840978-11-12441-12458

> 📌 过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。有关的详细信息请阅读下一节。 
> ⏱ 2022-10-31 13:11:45 ^840978-11-12459-12537

> 📌 人们认为两个字节的代码宽度足以对世界上各种语言的所有字符进行编码，并有足够的空间留给未来的扩展。 
> ⏱ 2022-10-31 13:16:08 ^840978-11-14626-14674

> 📌 65536个，其主要原因是增加了大量的汉语、日语和韩语中的表意文字。现在，16位的char类型已经不能满足描述所有Unicode字符的需要了 
> ⏱ 2022-10-31 13:16:39 ^840978-11-14834-14904

> 📌 码点（code point）是指与一个编码表中的某个字符对应的代码值 
> ⏱ 2022-10-31 13:17:09 ^840978-11-15002-15043

> 📌 我们强烈建议不要在程序中使用char类型，除非确实需要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理 
> ⏱ 2022-10-31 13:23:57 ^840978-11-16161-16217

> 📌 由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串 
> ⏱ 2022-10-31 13:31:11 ^840978-11-41660-41706

> 📌 让它引用另外一个字符串，这就如同可以将存放3的数值变量改成存放4一样。 
> ⏱ 2022-10-31 13:31:31 ^840978-11-41790-41825

> 📌 不可变字符串却有一个优点：编译器可以让字符串共享。 
> ⏱ 2022-10-31 13:31:49 ^840978-11-41945-41970

> 📌 返回的不是一个空格，而是[插图] 的第二个代码单元。为了避免这个问题，不要使用char类型。这太底层了。 
> ⏱ 2022-11-03 22:59:01 ^840978-11-49182-49366

### 4.1 面向对象程序设计概述

> 📌 final关键字只是表示存储在evaluations变量中的对象引用不会再指示其他StringBuilder对象。不过这个对象可以更改： 
> ⏱ 2022-11-03 23:27:09 ^840978-13-37976-38044

> 📌 Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。 
> ⏱ 2022-11-03 23:34:30 ^840978-13-47342-47408

> 📌 这个过程说明：Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的 
> ⏱ 2022-11-03 23:38:50 ^840978-13-51231-51275

> 📌 id域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。 
> ⏱ 2022-11-03 23:42:53 ^840978-13-61694-61734

> 📌 有个名为System.runFinalizersOnExit(true)的方法能够确保finalizer方法在Java关闭前被调用 
> ⏱ 2022-11-04 19:38:09 ^840978-13-65731-65796

> 📌 java.time.*的语法比较简单，对代码的大小也没有任何负面影响。 
> ⏱ 2022-11-04 19:42:01 ^840978-13-67929-67964

> 📌 javac编译器总是在当前的目录中查找文件，但Java虚拟机仅在类路径中有“.”目录的时候才查看当前目录 
> ⏱ 2022-11-05 16:26:28 ^840978-13-80153-80205

### 5.1 类、超类和子类

> 📌 反射库（reflection library）提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序 
> ⏱ 2022-11-05 22:46:48 ^840978-15-83140-83208

> 📌 能够分析类能力的程序称为反射 
> ⏱ 2022-11-05 22:50:50 ^840978-15-83373-83415

> 📌 使用它的主要人员是工具构造者，而不是应用程序员。 
> ⏱ 2022-11-05 22:51:25 ^840978-15-83713-83737

> 📌 除非所有继承的方法都有意义，否则不要使用继承 
> ⏱ 2022-11-06 00:02:58 ^840978-15-112375-112397

> 📌 使用多态，而非类型信息 
> ⏱ 2022-11-06 00:04:00 ^840978-15-113850-113861

> 📌 并将其放置在两个类的超类或接口中， 
> ⏱ 2022-11-06 00:04:56 ^840978-15-114264-114281

> 📌 使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展。 
> ⏱ 2022-11-06 00:06:17 ^840978-15-114557-114596

### 6.1 接口

> 📌 继续介绍lambda表达式，这是一种表示可以在将来某个时间点执行的代码块的简洁方法 
> ⏱ 2022-11-07 09:17:05 ^840978-17-649-718

> 📌 可以用一种精巧而简洁的方式表示使用回调或变量行为的 
> ⏱ 2022-11-07 09:17:18 ^840978-17-731-756

> 📌 虽然在接口中不能包含实例域或静态方法，但却可以包含常量 
> ⏱ 2022-11-07 09:25:14 ^840978-17-11889-11916

> 📌 现在可以直接在接口中实现方法。 
> ⏱ 2022-11-07 09:40:17 ^840978-17-17321-17336

> 📌 在我们的例子中，Student从Person继承了getName方法，Named接口是否为getName提供了默认实现并不会带来什么区别。 
> ⏱ 2022-11-07 13:21:34 ^840978-17-20456-20525

> 📌 回调（callback）是一种常见的程序设计模式。 
> ⏱ 2022-11-07 13:22:22 ^840978-17-21209-21241

> 📌 由于对象可以携带一些附加的信息，所以传递一个对象比传递一个函数要灵活得多 
> ⏱ 2022-11-07 13:25:22 ^840978-17-21659-21695

> 📌 标准库中只有不到5%的类实现了clone。 
> ⏱ 2022-11-08 13:19:33 ^840978-17-33079-33100

> 📌 lambda表达式就是一个代码块，以及必须传入代码的变量规范。 
> ⏱ 2022-11-08 13:27:03 ^840978-17-36966-36997

> 📌 ，如ActionListener或Comparator。lambda表达式与这些接口是兼容的。对于只有一个抽象方法 
> ⏱ 2022-11-08 18:58:33 ^840978-17-39965-40051

> 📌 Arrays.sort方法会接收实现了Comparator<String>的某个类的对象。在这个对象上 
> ⏱ 2022-11-08 19:00:37 ^840978-17-40915-40966

> 📌 。这些对象和类的管理完全取决于具体实现， 
> ⏱ 2022-11-08 19:00:55 ^840978-17-40993-41013

> 📌 另外要接受lambda表达式可以传递到函数式接口 
> ⏱ 2022-11-08 19:01:24 ^840978-17-41063-41087

> 📌 实际上，在Java中，对lambda表达式所能做的也只是能转换为函数式接口。 
> ⏱ 2022-11-08 19:01:53 ^840978-17-41461-41499

> 📌 方法引用不能独立存在，总是会转换为函数式 
> ⏱ 2022-11-09 00:12:28 ^840978-17-45038-45058

> 📌 在Java中，lambda表达式就是闭包。 
> ⏱ 2022-11-09 00:20:10 ^840978-17-48681-48702

> 📌 在lambda表达式中，只能引用值不会改变的变 
> ⏱ 2022-11-09 00:21:22 ^840978-17-48800-48823

> 📌 之所以有这个限制是有原因的。如果在lambda表达式中改变变量，并发执行多个动作时就会不安全 
> ⏱ 2022-11-09 00:21:56 ^840978-17-49054-49100

> 📌 lambda表达式的体与嵌套块有相同的作用域。这里同样适用命名冲突和遮蔽的有关规则。在lambda表达式中声明与一个局部变量同名的参数或局部变量是不合法的。 
> ⏱ 2022-11-09 00:24:26 ^840978-17-49654-49732

> 📌 lambda表达式中this的含义并没有变化。 
> ⏱ 2022-11-09 00:25:49 ^840978-17-50436-50459

> 📌 使用lambda表达式的重点是延迟执行 
> ⏱ 2022-11-09 00:26:52 ^840978-17-50657-50676

> 📌 如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息。另外javadoc页里会指出你的接口是一个函数式接口。 
> ⏱ 2022-11-09 13:18:47 ^840978-17-54304-54362

> 📌 内部类可以对同一个包中的其他类隐藏起来。 
> ⏱ 2022-11-11 09:45:02 ^840978-17-56975-56995

> 📌 内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。 
> ⏱ 2022-11-11 09:59:31 ^840978-17-59640-59674

> 📌 生成了一个默认的构造器，其代码如下所示 
> ⏱ 2022-11-11 10:00:16 ^840978-17-60401-60420

> 📌 外层括号建立了ArrayList的一个匿名子类 
> ⏱ 2022-11-12 19:00:28 ^840978-17-75606-75629

> 📌 内层括号则是一个对象构造块（见第4章 
> ⏱ 2022-11-12 19:00:35 ^840978-17-75630-75648

> 📌 并不需要内部类引用外围类对象。为此，可以将内部类声明为static，以便取消产生的引用。 
> ⏱ 2022-11-12 19:06:34 ^840978-17-77135-77179

> 📌 静态内部类的对象除了没有对生成它的外围类对象的引用特权外，与其他所有内部类完全一样 
> ⏱ 2022-11-13 14:52:50 ^840978-17-78946-78987

> 📌 调用编译器；然后再加载结果类 
> ⏱ 2022-11-14 09:26:02 ^840978-17-81144-81158

> 📌 很自然，这样做的速度会比较慢，并且需要将编译器与程序放在一起。 
> ⏱ 2022-11-14 09:26:15 ^840978-17-81161-81192

> 📌 克隆和代理是库设计者和工具构造者感兴趣的高级技术，对应用程序员来说，它们并不十分重要。 
> ⏱ 2022-11-15 13:10:11 ^840978-17-87615-87658

### 7.1 处理错误

> 📌 充满了不良的数据和带有问题的代码，现在 
> ⏱ 2022-11-15 13:11:59 ^840978-19-520-539

> 📌 向用户通告错误 
> ⏱ 2022-11-15 13:12:11 ^840978-19-721-728

> 📌 保存所有的工作结果 
> ⏱ 2022-11-15 13:12:16 ^840978-19-761-770

> 📌 Error类层次结构描述了Java运行时系统的内部错误和资源耗尽错误。 
> ⏱ 2022-11-15 13:14:47 ^840978-19-3521-3556

> 📌 应用程序不应该抛出这种类型的对象 
> ⏱ 2022-11-15 13:14:55 ^840978-19-3556-3572

> 📌 出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也 
> ⏱ 2022-11-15 13:15:05 ^840978-19-3575-3610

> 📌 而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。 
> ⏱ 2022-11-15 13:15:35 ^840978-19-3774-3809

> 📌 编译器将核查是否为所有的受查异常提供了异常处理器 
> ⏱ 2022-11-15 13:17:42 ^840978-19-4624-4648

> 📌 样，也不应该声明从RuntimeException继承的那些非受查异 
> ⏱ 2022-11-15 13:19:32 ^840978-19-7427-7461

> 📌 如果特别关注数组下标引发的错误，就应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性上 
> ⏱ 2022-11-15 13:19:44 ^840978-19-7698-7752

> 📌 一个方法必须声明所有可能抛出的受查异 
> ⏱ 2022-11-15 13:19:51 ^840978-19-7785-7824

> 📌 可控制（Error），要么就应该避免发生（RuntimeException） 
> ⏱ 2022-11-15 13:19:56 ^840978-19-7842-7880

> 📌 强烈建议使用这种包装技术。这样可以让用户抛出子系统中的高级异常，而不会丢失原始异常的细节。 
> ⏱ 2022-11-15 18:57:43 ^840978-19-18625-18670

> 📌 让高层次的方法通知用户发生了错误，或者放弃不成功的命令更加适宜。 
> ⏱ 2022-11-15 19:03:00 ^840978-19-33773-33805

> 📌 规则5、6可以归纳为“早抛出，晚捕获” 
> ⏱ 2022-11-15 19:03:04 ^840978-19-34017-34036

> 📌 用或禁用断言是类加载器（class loader）的功能。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。 
> ⏱ 2022-11-15 23:31:50 ^840978-19-37192-37256

> 📌 断言检查只用于开发和测阶段（这种做法有时候被戏称为“在靠近海岸时穿上救生衣，但在海中央时就把救生衣抛掉吧”）。 
> ⏱ 2022-11-15 23:33:55 ^840978-19-38471-38526

> 📌 断言只应该用于在测试阶段确定程序内部的错误位置。 
> ⏱ 2022-11-15 23:34:59 ^840978-19-38607-38631

> 📌 通常，将一个程序中的错误信息保存在一个文件中是非常有用的。然而，错误信息被发送到System.err中，而不是System.out中。因此，不能够通过运行下面的语句获取它们： 
> ⏱ 2022-11-15 23:52:09 ^840978-19-73094-73181

### 8.1 为什么要使用泛型程序设计

> 📌 。注意，类型变量放在修饰符（这里是public static）的后面，返回类型的前面。 
> ⏱ 2022-11-17 18:16:08 ^840978-21-7929-7972

> 📌 需要记住有关Java泛型转换的事实：
● 虚拟机中没有泛型，只有普通的类和方法。
● 所有的类型参数都用它们的限定类型替换。
● 桥方法被合成来保持多态。
● 为保持类型安全性，必要时插入强制类型转换。 
> ⏱ 2022-11-22 23:21:21 ^840978-21-19629-19846

> 📌 通配符不是类型变量，因 
> ⏱ 2022-11-23 23:17:38 ^840978-21-49323-49334

### 9.1 Java集合框架

> 📌 hashCode方法的定义要保证包含相同元素的两个集会得到相同的散列码 
> ⏱ 2022-11-26 18:28:31 ^840978-23-15814-15849

### 14.1 什么是线程

> 📌 当对一个线程调用interrupt方法时，线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志，以判断线程是否被中断。 
> ⏱ 2022-11-27 12:47:40 ^840978-33-9744-9826

> 📌 （存在不能被中断的阻塞I/O调用，应该考虑选择可中断的调用。有关 
> ⏱ 2022-11-27 12:48:44 ^840978-33-10266-10298

> 📌 被中断的线程可以决定如何响应中断。 
> ⏱ 2022-11-27 12:49:04 ^840978-33-10386-10403

> 📌 某些线程是如此重要以至于应该处理完异常后，继续执行，而不理会中 
> ⏱ 2022-11-27 12:49:14 ^840978-33-10403-10434

> 📌 如果在每次工作迭代之后都调用sleep方法（或者其他的可中断方法）, isInterrupted检测既没有必要也没有用处。 
> ⏱ 2022-11-27 12:50:31 ^840978-33-10700-10761

> 📌 记住，在任何给定时刻，一个可运行的线程可能正在运 
> ⏱ 2022-11-27 12:55:52 ^840978-33-14669-14693

> 📌 守护线程的唯一用途是为其他线程提供服务 
> ⏱ 2022-11-27 13:28:05 ^840978-33-19310-19329

> 📌 当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没必要继续运行程序了 
> ⏱ 2022-11-27 13:28:14 ^840978-33-19376-19417

> 📌 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断 
> ⏱ 2022-11-27 13:28:44 ^840978-33-19496-19544

> 📌 编译器被要求通过在必要的时候刷新本地缓存来保持锁的效应 
> ⏱ 2022-11-29 12:51:22 ^840978-33-45358-45385

> 📌 。如果另一个线程已经对该对象加锁 
> ⏱ 2022-11-29 12:53:18 ^840978-33-46478-46494

> 📌 不能保证读取、翻转和写入不被中断。 
> ⏱ 2022-11-29 12:53:48 ^840978-33-47273-47290

> 📌 假设对共享变量除了赋值之外并不完成其他操作，那么可以将这些共享变 
> ⏱ 2022-11-29 12:55:38 ^840978-33-47995-48027

> 📌 量声明为volatile 
> ⏱ 2022-11-29 12:55:42 ^840978-33-48027-48039

# 读书笔记

# 本书评论
