---
doc_type: weread-highlights-reviews
bookId: "38209697"
author: 唐卓章
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/697/38209697/t7_38209697.jpg
reviewCount: 3
noteCount: 109
readingStatus: 读完
progress: 100%
totalReadDay: 19
readingTime: 8小时52分钟
readingDate: 2021-12-31
finishedDate: 2022-02-07
isbn: 9787121408274
lastReadDate: 2022-02-07

---
# 元数据
> [!abstract] MongoDB进阶与实战：微服务整合、性能优化、架构管理
> - ![ MongoDB进阶与实战：微服务整合、性能优化、架构管理|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/697/38209697/t7_38209697.jpg)
> - 书名： MongoDB进阶与实战：微服务整合、性能优化、架构管理
> - 作者： 唐卓章
> - 简介： 本书围绕如何用好MongoDB这个复杂命题，利用大部分篇幅讲述了MongoDB在应用开发方面的各种进阶技巧，同时也介绍了MongoDB 4.0版本的事务特性及微服务相关的技术范例。很多基本的数据库问题都可以从MongoDB的官方文档中找到答案，但官方文档中在MongoDB周边技术栈的整合、系统管理及调优方面仍然缺乏一些富有针对性的内容，所以本书在结合一些实践案例的前提下，以开发管理者的角度对MongoDB技术进行了系统地梳理，希望能够让读者的学习达到事半功倍的效果。相信本书会对应用MongoDB的开发人员具有广泛的指导意义。
> - 出版时间 2021-04-01 00:00:00
> - ISBN： 9787121408274
> - 分类： 计算机-编程设计
> - 出版社： 电子工业出版社
> - PC地址：https://weread.qq.com/web/reader/f1232340724708a1f128522

# 高亮划线

## 前言

> 📌 自身的感受来说，采用传统的关系型数据库可能是一种“万金油”的方案 
> ⏱ 2021-12-31 00:17:16 ^38209697-4-690-722

> 📌 敏捷开发、高效扩展 
> ⏱ 2021-12-31 00:17:28 ^38209697-4-758-767

> 📌 命名者的意图是可以处理大规模的数 
> ⏱ 2021-12-31 00:18:44 ^38209697-4-828-844

> 📌 一方面，MongoDB的文档模型是基于JSON的，开发者更容易理解。另一方面，动态化模式的特性让数据库的管理工作变得更加简单，例如一些线上的变更可以更快速地完成。 
> ⏱ 2021-12-31 00:19:15 ^38209697-4-996-1077

> 📌 交付一时爽，维护火葬场 
> ⏱ 2021-12-31 00:21:16 ^38209697-4-1268-1279

> 📌 MongoDB在使用上仍然需要认真地考量和看护 
> ⏱ 2021-12-31 00:21:32 ^38209697-4-1318-1341

## 第1部分 MongoDB入门

> 📌 实际上，所有的读写都是基于一种内部隐含的模式，模式采取按需变更而非提前声明，因此动态模式一词更适合它。 
> ⏱ 2021-12-31 00:29:28 ^38209697-5-1905-1956

> 📌 包括单键索引、复合索引，唯一索引等一些常用的结构。 
> ⏱ 2022-01-07 12:50:57 ^38209697-5-2073-2098

> 📌 因此它也同样支持对嵌套字段、数组进行索引。 
> ⏱ 2022-01-07 12:51:08 ^38209697-5-2113-2134

> 📌 值得一提的是，MongoDB的索引实现与一般的关系型数据库索引并没有太多不同，因此，我们几乎可以使用某种“一致的思路”来设计索引或完成一些性能调优的任务。 
> ⏱ 2022-01-07 12:51:50 ^38209697-5-2161-2245

> 📌 么团队成员可能已经习惯于使用各种复杂连接（join）、多重嵌套子查询等SQL用法。MongoDB在这方面的支持较弱，尽管可以通过聚合操作实现类似的效果，但这并非最佳实践 
> ⏱ 2022-01-07 13:03:19 ^38209697-5-5358-5442

> 📌 。利用数据库本身的事务性保证，还可以实现分布式事务，这对于提升系统的可伸缩性有明显的效果。 
> ⏱ 2022-01-07 13:07:55 ^38209697-5-5654-5699

#### 1.2 类比SQL模型

> 📌 除了松散的表结构，文档还可以支持多级的嵌套、数组等灵活的数据类型，非常契合面向对象的编程模型。 
> ⏱ 2022-01-07 13:10:36 ^38209697-6-1790-1837

> 📌 弱关系，MongoDB没有外键的约束，也没有非常强大的表连接能力。类似的功能需要使用聚合管道技术来弥补。 
> ⏱ 2022-01-07 13:10:45 ^38209697-6-1853-1905

#### 3.3 ObjectId生成器

> 📌 对于新插入集合中的文档，如果没有包含_id字段，则数据库服务器会自动生成一个新的ObjectId。 
> ⏱ 2022-01-08 09:39:47 ^38209697-18-1237-1286

> 📌 还可以降低MongoDB服务器端的计算压力 
> ⏱ 2022-01-08 09:40:17 ^38209697-18-1376-1397

#### 3.4 数组、内嵌

> 📌 使用序列化的单列进行收敛，比 
> ⏱ 2022-01-08 09:41:40 ^38209697-19-694-708

> 📌 如将数组或子对象转换为JSON字符串后存储到某个列，在读取时再进行解析。 
> ⏱ 2022-01-08 09:41:45 ^38209697-19-708-744

> 📌 单列序列化的方式带来了应用上的复杂性，数据库无法理解该列的内部结构，所能提供的操作只有“整存整取”。 
> ⏱ 2022-01-08 09:42:08 ^38209697-19-833-883

> 📌 ，除了可以方便地对数组内的元素、内嵌文档的字段进行操作，还可以对这些“内嵌式”的字段进行索引以满足快速的查询。 
> ⏱ 2022-01-08 09:42:28 ^38209697-19-926-981

> 📌 这是文档型数据库的一种强大的表现力。 
> ⏱ 2022-01-08 09:44:42 ^38209697-19-1005-1023

> 📌 MySQL、PostgreSQL在后来也支持数组和内嵌对象的类型，充分说明了该能力的重要性及普适性。 
> ⏱ 2022-01-08 09:44:57 ^38209697-19-1052-1102

> 📌 如果作者信息需要修改，则可以指定其中的某个字段，比如修改作者的家乡所在地，代码如下： 
> ⏱ 2022-01-08 09:46:13 ^38209697-19-1862-1904

#### 3.6 小技巧——使用固定集合实现FIFO队列

> 📌 比如查询某个时间点之后的数据，可以为timestamp添加索引，代码如下： 
> ⏱ 2022-01-17 09:19:40 ^38209697-21-1467-1504

### 第4章 索引介绍

> 📌 2.索引的分类 
> ⏱ 2022-01-17 09:27:04 ^38209697-22-1005-1012

#### 4.3 数组索引

> 📌 为了避免失控，有必要在文档的设计上做出一些限制。 
> ⏱ 2022-01-19 09:25:21 ^38209697-24-1206-1230

#### 4.6 TTL索引

> 📌 除了数据老化功能，TTL索引具有普通索引的功能，同样可以用于加速数据的查询。 
> ⏱ 2022-01-19 14:14:42 ^38209697-27-1289-1327

### 第5章 副本集

> 📌 备节点能主动发起选举并产生新的主节点进行接管， 
> ⏱ 2022-01-21 09:54:38 ^38209697-30-1263-1286

#### 5.2 集群选举

> 📌 这是一种使用广泛的分布式一致性算法， 
> ⏱ 2022-01-21 09:56:55 ^38209697-31-488-506

#### 5.3 实时复制

> 📌 这里会用到可持续追踪的游标（tailable cursor）技术，如图5-12所示。 
> ⏱ 2022-01-21 17:05:19 ^38209697-32-1881-1923

> 📌 在执行同步时就通过这个optime向主节点的oplog集合发起查询。 
> ⏱ 2022-01-21 17:06:00 ^38209697-32-2211-2245

> 📌 这样只要oplog中产生了新的记录，备节点就能使用同样的请求通道获得这些数据。 
> ⏱ 2022-01-21 17:06:20 ^38209697-32-2304-2343

> 📌 inc操作，代码如下：[插图]在oplog中转换为$set操作，直接写入变更后的值，代码如下： 
> ⏱ 2022-01-21 17:07:55 ^38209697-32-3483-3708

### 第6章 分片

> 📌 查询路由（mongos）：mongos是分片集群的访问入口，其本身并不持久化数据。 
> ⏱ 2022-01-22 14:54:38 ^38209697-36-1873-1915

#### 6.7 小技巧——使用标签

> 📌 分片策略只影响数据所在的chunk，而chunk所在的分片则是由均衡器来调整的， 
> ⏱ 2022-01-22 23:11:12 ^38209697-42-597-637

> 📌  对于没有做任何声明的集合，则会被分发到任意一个分片上。 ^38209697-42-1748-1775
- 💭 分片是库维度的，不是集合 - ⏱ 2022-01-22 23:17:41 

#### 7.3 CAP与BASE理论

> 📌 在现实中网络时延一定是真实存在的，也就是P一定是存在的。 
> ⏱ 2022-01-24 00:07:40 ^38209697-45-1653-1681

> 📌 CA的场景是无法存在的，因为网络通信失败的情况一定会存在。 
> ⏱ 2022-01-24 00:07:34 ^38209697-45-1769-1798

> 📌 写主节点，读备节点，那么可用性提高了，但一致性却降低了，这是AP。 
> ⏱ 2022-01-24 00:09:15 ^38209697-45-2919-2952

#### 9.5 高级操作

> 📌 其中，projectClass表示要进行投射的Pojo接口类型。借助此方法，我们还可以实现多种不同的投射类型。尝试执行如下的代码片段： 
> ⏱ 2022-02-03 20:05:47 ^38209697-59-1066-1133

#### 9.6 自定义配置

> 📌 只要发现有其他地方声明了Bean，那么自动配置的Bean就不再有效了，这点也是SpringBoot自动配置的关键。 
> ⏱ 2022-02-03 20:23:27 ^38209697-60-4179-4236

#### 9.10 小技巧——自定义数据序列化方式

> 📌 重点是读者可以借助这种自定义Converter的机制，解决一些特定场景中的需求，例如，为所有的密码字段实现可逆的加解密存取，等等。 
> ⏱ 2022-02-03 23:09:27 ^38209697-64-3836-3901

#### 11.2 WiredTiger读写模型

> 📌 MongoDB单机下保证数据可靠性的机制包括以下两个部分 
> ⏱ 2022-02-03 23:41:35 ^38209697-72-1782-1810

> 📌 则其在断电情况下最多会丢失100ms的写入数据。 
> ⏱ 2022-02-03 23:43:27 ^38209697-72-2449-2473

### 第12章 合理使用索引

> 📌 大部分基于SQL数据库的索引调优技巧在MongoDB上仍然是可行的 
> ⏱ 2022-02-04 09:21:07 ^38209697-76-1807-1840

#### 12.3 覆盖索引

> 📌 ，覆盖索引式的查询可以保证一次检索行为仅仅发生在内存中，即避免了对磁盘的I/O操作，这对于性能的提升有显著的效果。 
> ⏱ 2022-02-04 16:14:40 ^38209697-78-623-680

#### 12.4 查询计划

> 📌 其根据索引查找的结果（叶子节点指针）执行最终文档的获取操作 
> ⏱ 2022-02-04 16:18:27 ^38209697-79-1713-1742

#### 12.5 实战：查询案例分析

> 📌 ：由于{y：1，z：-1}排序条件 
> ⏱ 2022-02-04 16:24:48 ^38209697-80-6727-6744

> 📌 与组合索引的字段顺序不一致，因而产生了内存排序 
> ⏱ 2022-02-04 16:24:52 ^38209697-80-6744-6767

> 📌 说明：该查询中由于x不是等值 
> ⏱ 2022-02-04 16:26:58 ^38209697-80-8441-8455

> 📌 配，因此{y：1，z：1}的排序无法利用组合索引的顺序，此时产生了内存排序。最后的计算顺序与案例8类似。 
> ⏱ 2022-02-04 16:27:03 ^38209697-80-8456-8508

> 📌 ，数据库会使用归并排序（SORT_MERGE）的方式来保证结果的有序性，如图12-2所示。最终，查询过程只需要扫描limit对应的条目数。 
> ⏱ 2022-02-04 16:30:41 ^38209697-80-9194-9263

#### 12.10 优化原则

> 📌 ，另外，组合索引上也应尽量将基数高的字段放在前面。 
> ⏱ 2022-02-04 16:43:11 ^38209697-85-1130-1155

> 📌 写操作性能降低，一次文档写入会触发多个索引的更新，增加了系统I/O开销。 
> ⏱ 2022-02-04 16:43:34 ^38209697-85-1376-1413

> 📌 ，开发者往往会使用save命令保存整个文档，此时将会触发集合中所有索引的更新 
> ⏱ 2022-02-04 16:43:53 ^38209697-85-1456-1494

> 📌 如果能在update操作中明确指定需要更新的字段，那么影响则会减少一些。也就是说，只有当索引中的字段被update指定时才会触发更新。 
> ⏱ 2022-02-04 16:44:12 ^38209697-85-1495-1562

> 📌 x：1，y：1，z：1}同时具备{x：1}索引和{x：1，y：1}索引的功能，因此后面两个索引可以去掉。 
> ⏱ 2022-02-04 16:45:01 ^38209697-85-2038-2090

### 第13章 并发优化

> 📌 ，其内部使用了MVCC乐观锁的方式来实现并发控制 
> ⏱ 2022-02-04 16:48:23 ^38209697-86-956-980

#### 13.2 MVCC

> 📌 在并发场景下，用于保证一致性的做法一般有两种 
> ⏱ 2022-02-04 16:59:24 ^38209697-87-410-432

> 📌 。我们可以将MVCC看成行级锁的一种妥协，它在许多情况下避免了使用锁 
> ⏱ 2022-02-04 16:59:15 ^38209697-87-689-723

> 📌 文档的更新是一种copy on write的方式，每一次修改都会被附加到链表的头部 
> ⏱ 2022-02-04 17:01:23 ^38209697-87-1148-1189

> 📌 ，则会写入数据的delete标记，读取时进行判别就可以了。 
> ⏱ 2022-02-04 17:02:02 ^38209697-87-1229-1258

> 📌 而只有在多个线程尝试更新同一个记录时才会产生写冲突（write confict），此时只会有一个更新操作成功，其他操作会 
> ⏱ 2022-02-04 17:02:57 ^38209697-87-1299-1359

> 📌 多文档事务提供了基于快照一致性的读能力，这同样离不开MVCC。 
> ⏱ 2022-02-04 17:04:01 ^38209697-87-1668-1699

#### 13.3 原子性操作

> 📌 ，但始终是一个全量保存的动作 
> ⏱ 2022-02-04 17:10:14 ^38209697-88-2798-2812

> 📌 则很容易造成带宽的浪费 
> ⏱ 2022-02-04 17:10:26 ^38209697-88-2879-2890

> 📌 一旦集合中存在多个索引， 
> ⏱ 2022-02-04 17:10:38 ^38209697-88-2907-2919

> 📌 档的更新还会同时触发多个索引的I/O操作，这会增加写磁盘的压力。 
> ⏱ 2022-02-04 17:10:42 ^38209697-88-2920-2952

#### 13.5 缓解行锁竞争

> 📌 Redis的计数器实现更加高效和便捷，这得益于其采用了单线程计算模式，在执行incr命令时并不存在多线程竞争的问题。 
> ⏱ 2022-02-04 17:28:13 ^38209697-90-3189-3247

### 第14章 应用设计调优

> 📌 希望消除利用某个列存储多值的行为，而且每个列都可以独立进行查询。 
> ⏱ 2022-02-05 10:45:04 ^38209697-93-1112-1144

> 📌 如果采用了反范式的做法，则务必要仔细考虑冗余和数据一致性的问题 
> ⏱ 2022-02-07 08:15:55 ^38209697-93-3033-3064

> 📌 如果是数据频繁变化，或者一致性要求非常高的场景，则建议用范式设计 
> ⏱ 2022-02-07 08:16:03 ^38209697-93-3065-3097

> 📌 范式设计一般会更容易适应未来的一些变化。从 
> ⏱ 2022-02-07 08:16:58 ^38209697-93-3160-3181

#### 14.2 嵌套设计

> 📌 正如前面所言，范式/反范式关注的是冗余问题，而嵌套则更多的是关注文档对象之间的结构化关系 
> ⏱ 2022-02-07 08:18:30 ^38209697-94-498-542

> 📌 此外，在嵌套式的文档内查找属性还会更快一些。 
> ⏱ 2022-02-07 08:19:13 ^38209697-94-875-897

> 📌 整体文档的大小不能超过16MB。 
> ⏱ 2022-02-07 08:21:35 ^38209697-94-1830-1846

> 📌 关联的子文档保持独立性，仅在父文档增加少量的引用，这样不需要 
> ⏱ 2022-02-07 08:22:34 ^38209697-94-2685-2715

> 📌 在子文档中引入额外的索引。 
> ⏱ 2022-02-07 08:22:39 ^38209697-94-2715-2728

#### 14.6 读写分离与一致性

> 📌 客户端必须在同一个线程中执行这些操作。 
> ⏱ 2022-02-07 16:13:55 ^38209697-98-8253-8272

#### 14.7 聚合范例

> 📌 非常方便，但这个视图是动态执行的，每次对视图的查询都需要重新执行整个聚合管道，从成本效果上讲受益不大 
> ⏱ 2022-02-07 16:24:20 ^38209697-99-3881-3931

> 📌 那么MongoDB会随机选择一个分片作为执行者，并由该分片负责合并处理来自其他分片的结果 
> ⏱ 2022-02-07 16:29:30 ^38209697-99-7286-7330

#### 15.2 Change Stream案例：数据迁移

> 📌 这其中，保证数据的平滑迁移往往会成为一个非常重要且复杂的工作。 
> ⏱ 2022-02-07 16:33:40 ^38209697-101-572-603

#### 15.3 多文档事务

> 📌 ：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。 
> ⏱ 2022-02-07 16:42:15 ^38209697-102-1010-1040

> 📌 其数据的中间状态是彼此不可见的 
> ⏱ 2022-02-07 16:42:45 ^38209697-102-1203-1218

> 📌 的“有无”发生变化。 
> ⏱ 2022-02-07 16:52:51 ^38209697-102-1560-1570

> 📌 此后第一个事务将会发现还存在没有修改的数据行，就好像出现了幻觉一样。 
> ⏱ 2022-02-07 16:43:31 ^38209697-102-1613-1647

> 📌 事务在执行过程中，可能访问到其他事务未经提交的修改，这种级别是最弱的，无法避免“脏读” 
> ⏱ 2022-02-07 16:43:55 ^38209697-102-1728-1771

> 📌 事务在执行时，可以读取另一个事务已经提交到数据库的结果 
> ⏱ 2022-02-07 16:45:18 ^38209697-102-1809-1836

> 📌 因此会存在无法重复读的问题。 
> ⏱ 2022-02-07 16:45:51 ^38209697-102-1868-1882

> 📌 当前事务只能读取到本事务所做出的修改。 
> ⏱ 2022-02-07 16:48:37 ^38209697-102-1958-1977

> 📌 事务还是会读取到其他事务提交的新增数据。 
> ⏱ 2022-02-07 16:48:41 ^38209697-102-2000-2020

> 📌 而解决幻读问题的手段，一般是采用MVCC或者锁机制来实现。 
> ⏱ 2022-02-07 16:51:57 ^38209697-102-2494-2523

> 📌 开始便对单文档的操作提供了事务原子性的保证。 
> ⏱ 2022-02-07 16:54:46 ^38209697-102-2747-2769

> 📌 提供了跨分片的分布式事务，事务能力得到了进一步完善。 
> ⏱ 2022-02-07 16:55:07 ^38209697-102-2846-2872

> 📌 MongoDB的快照隔离级别是比可重复读更严谨的一种级别，除了解决不可重复读的问题，还避免了幻读，如上述过程中，事务一的提交中尽管插入了新的记录，但在事务二中仍然无法读取出来。 
> ⏱ 2022-02-07 16:57:41 ^38209697-102-5484-5572

> 📌 设置1分钟的超时时间， 
> ⏱ 2022-02-07 16:57:55 ^38209697-102-6025-6036

#### 15.4 基于Spring开发事务

> 📌 对此官方建议使用Spring Retry组件来解决此类问题。 
> ⏱ 2022-02-07 17:02:44 ^38209697-103-4969-4999

#### 15.5 事务实现原理

> 📌 WiredTiger对事务的支持同时包含了未提交读、提交读、快照一致性读。而MongoDB事务采用的是快照一致性读。 
> ⏱ 2022-02-07 17:48:19 ^38209697-104-2551-2609

> 📌 [插图]
图15-7 事务持久性
15.5.3 读写隔离设定
在读写级别方面，多文档事务会产生一些不同的约束。
（1）readPreference
在多文档事务中，readPreference被强制约束为Primary，即客户端对事务的读操作只能通过主节点完成。 
> ⏱ 2022-02-07 17:50:54 ^38209697-104-3144

#### 15.7 使用事务的限制

> 📌 分布式事务是基于二阶段提交的，相比之前的单文档事务模式来说，性能有一定的降级。在业务表设计上，建议尽可能利用单文档模型来保证数据的一致性和完整性。 
> ⏱ 2022-02-07 18:01:36 ^38209697-106-1765-1838

#### 17.3 应用层高可靠

> 📌 对于前者通常需要实时响应（如响应时延在20ms），而后者则允许有一定的时延。如果仅使用一个连接池，则很容易出现连接抢占的情况。 
> ⏱ 2022-02-07 18:18:17 ^38209697-113-847-910

> 📌 ，考虑在应用内部为不同业务启用单独的连接池，可以降低这类风险 
> ⏱ 2022-02-07 18:18:47 ^38209697-113-1034-1064

> 📌 将不同的业务数据存储到不同分片区域中， 
> ⏱ 2022-02-07 18:19:37 ^38209697-113-1721-1740

#### 17.4 备份可靠性

> 📌 则可以使用LVM来创建快照备份卷， 
> ⏱ 2022-02-07 18:21:21 ^38209697-114-3830-3847

#### 17.5 容灾可靠性

> 📌 可以自己实现连接器代码，或者使用开源框架，如MongoShake。 
> ⏱ 2022-02-07 18:27:33 ^38209697-115-2716-2749

#### 18.3 规范与自动化

> 📌 避免建立过多的索引，单个集合建议不超过10个索引 
> ⏱ 2022-02-07 21:34:38 ^38209697-118-1732-1756

> 📌 考虑数据老化问题，要及时清理无效、过期的数据，优先考虑为系统日志、历史数据表添加合理的老化策略。 
> ⏱ 2022-02-07 21:36:37 ^38209697-118-2165-2213

> 📌 最大值建议不超过200。 
> ⏱ 2022-02-07 21:37:37 ^38209697-118-2490-2502

> 📌 则必须保证事务尽可能小，一个事务的执行时间最长不能超过60s。 
> ⏱ 2022-02-07 21:37:50 ^38209697-118-2600-2631

#### 18.4 运维管理

> 📌 每次API调用需要产生大约7次数据库操作， 
> ⏱ 2022-02-07 21:43:06 ^38209697-119-3013-3034

# 读书笔记

## 前言

### 划线评论
> 📌 第二层感受是“酸爽”  ^370982625-7vWDlig7K
    - 💭 爽  酸爽  玩呢？
    - ⏱ 2021-12-31 00:20:49
   
## 6.7 小技巧——使用标签

### 划线评论
> 📌 对于没有做任何声明的集合，则会被分发到任意一个分片上。  ^370982625-7wvyman3h
    - 💭 分片是库维度的，不是集合
    - ⏱ 2022-01-22 23:18:09
   
# 本书评论

## 书评 No.1 
 ^370982625-7wTNooDPm
⏱ 2022-02-07 21:47:50
