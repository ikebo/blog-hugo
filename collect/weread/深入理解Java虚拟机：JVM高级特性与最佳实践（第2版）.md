---
doc_type: weread-highlights-reviews
bookId: "603120"
author: 周志明
cover: https://cdn.weread.qq.com/weread/cover/26/YueWen_603120/t7_YueWen_603120.jpg
reviewCount: 0
noteCount: 272
readingStatus: 在读
progress: 96%
totalReadDay: 28
readingTime: 10小时53分钟
readingDate: 2022-04-01
isbn: 9787111421900
lastReadDate: 2023-01-20

---
# 元数据
> [!abstract] 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）
> - ![ 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）|200](https://cdn.weread.qq.com/weread/cover/26/YueWen_603120/t7_YueWen_603120.jpg)
> - 书名： 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）
> - 作者： 周志明
> - 简介： 全书共分为五大部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行了全面而深入的分析，深刻揭示了JVM的工作原理。第一部分从宏观的角度介绍了整个Java技术体系、Java和JVM的发展历程、模块化，以及JDK的编译，这对理解本书后面内容有重要帮助。第二部分讲解了JVM的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果；第五部分探讨了Java实现高效并发的原理，包括JVM内存模型的结构和操作；原子性、可见性和有序性在Java内存模型中的体现；先行发生原则的规则和使用；线程在Java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。
> - 出版时间 2013-06-01 00:00:00
> - ISBN： 9787111421900
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/9b832f305933f09b86bd2a9

# 高亮划线

## 第二部分 自动内存管理机制

> 📌 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据 
> ⏱ 2022-12-16 13:07:24 ^603120-5-5068-5106

> 📌 实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性； 
> ⏱ 2022-12-16 13:17:23 ^603120-5-9181-9212

> 📌 ，即每个线程在Java堆中预先分配一小块内存， 
> ⏱ 2022-12-16 13:18:57 ^603120-5-9240-9263

### 第3章 垃圾收集器与内存分配策略

> 📌 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收 
> ⏱ 2022-12-27 13:18:10 ^603120-6-15743-15864

> 📌 3.2节和3.3节从理论上介绍了对象存活判定算法和垃圾收集算法 
> ⏱ 2022-12-27 13:18:30 ^603120-6-15954-15985

> 📌 就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC 
> ⏱ 2023-01-02 16:29:09 ^603120-6-32478-32581

### 第5章 调优案例分析与实战

> 📌 这样可以通过在深夜执行定时任务的方式触发Full GC甚至自动重启应用服务器来保持内存可用空间在一个稳定的水平。 
> ⏱ 2023-01-08 20:39:40 ^603120-8-2274-2330

> 📌 主要对象的生存周期都应该是请求级或者页面级的 
> ⏱ 2023-01-08 20:40:42 ^603120-8-2494-2516

> 📌 64位JDK的性能测试结果普遍低于32位JDK。 
> ⏱ 2023-01-08 20:41:08 ^603120-8-2974-3156

> 📌 考虑到用户对响应速度比较关心，并且文档服务的主要压力集中 
> ⏱ 2023-01-08 20:44:24 ^603120-8-5209-5237

> 📌 磁盘和内存访问，CPU资源敏感度较低，因此改为CMS收集器进行垃圾回收。部署方式调整后，服务再没有出现长时间停顿，速度比硬件升级前有较大提升 
> ⏱ 2023-01-08 20:44:34 ^603120-8-5238-5308

> 📌 但不应当有过于频繁的写操作，那样会带来很大的网络同步的开销。 
> ⏱ 2023-01-08 20:47:00 ^603120-8-6848-6878

> 📌 线程堆栈 
> ⏱ 2023-01-08 20:50:10 ^603120-8-8982-8986

> 📌 如果代码中使用JNI调用本地库，那本地库使用的内存也不在堆中。 
> ⏱ 2023-01-08 20:50:45 ^603120-8-9560-9591

> 📌 虚拟机和GC：虚拟机、GC的代码执行也要消耗一定的内存 
> ⏱ 2023-01-08 20:50:54 ^603120-8-9750-9777

> 📌 用于保证程序在恢复最小化时能够立即响应。在这个案例中加入该参数后，问题得到解决 
> ⏱ 2023-01-08 21:03:42 ^603120-8-17174-17213

> 📌 开启了JMX管理（需要在VisualVM中收集原始数据） 
> ⏱ 2023-01-08 21:05:20 ^603120-8-17950-17978

> 📌 根据分析，优化计划确定为：把新生代容量提升到128MB，避免新生代频繁GC；把Java堆、永久代的容量分别固定为512MB和96MB￼，避免内存扩展 
> ⏱ 2023-01-08 21:21:51 ^603120-8-36688-36904

> 📌 读者实践的时候应根据VisualGC中收集到的实际数据进行设置 
> ⏱ 2023-01-08 21:22:04 ^603120-8-36938-36969

> 📌 回顾一下在第3章提到的几种收集器，很容易想到CMS是最符合这类场景的收集器。 
> ⏱ 2023-01-08 21:25:25 ^603120-8-40396-40434

> 📌 在GC日志中可以看到CMS与程序并发的时间约为400毫秒，这样收集器的运作结果就比较令人满意了 
> ⏱ 2023-01-08 21:25:48 ^603120-8-41005-41052

> 📌 总结几个参数让自己日常工作环境速度有较大幅度提升也是很划算的。最终eclipse.ini的配置如代码清单5-12所示。 
> ⏱ 2023-01-08 21:26:36 ^603120-8-41223-41334

> 📌 Java虚拟机的内存管理与垃圾收集是虚拟机结构体系中最重要的组成部分，对程序的性能和稳定性有非常大的影响 
> ⏱ 2023-01-08 21:27:04 ^603120-8-42323-42375

## 第三部分 虚拟机执行子系统

> 📌 譬如类或接口也可以通过类加载器直接生成 
> ⏱ 2023-01-09 09:23:16 ^603120-9-3669-3688

> 📌 都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变 
> ⏱ 2023-01-09 13:32:50 ^603120-9-5023-5062

> 📌 它是Class文件结构中与其他项目关联最多的数据类型 
> ⏱ 2023-01-11 00:08:41 ^603120-9-7384-7410

> 📌 需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中 
> ⏱ 2023-01-12 18:51:19 ^603120-9-8979-9020

> 📌 例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中， 
> ⏱ 2023-01-12 22:35:38 ^603120-9-47028-47063

> 📌 加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之间来回传输， 
> ⏱ 2023-01-12 22:38:45 ^603120-9-48795-48844

> 📌 方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。 
> ⏱ 2023-01-12 22:49:51 ^603120-9-62019-62060

> 📌 。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。 
> ⏱ 2023-01-12 22:50:04 ^603120-9-62184-62288

> 📌 那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。 
> ⏱ 2023-01-12 22:51:14 ^603120-9-62358-62390

> 📌 同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的， 
> ⏱ 2023-01-12 22:51:44 ^603120-9-62419-62460

> 📌 编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。 
> ⏱ 2023-01-12 22:54:41 ^603120-9-63881-63966

> 📌 编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。 
> ⏱ 2023-01-12 22:54:59 ^603120-9-64064-64122

> 📌 、运行时的角度去看看字节码流在虚拟机执行引擎中是怎样被解释执行的。 
> ⏱ 2023-01-13 13:22:43 ^603120-9-66679-66712

### 第7章 虚拟机类加载机制

> 📌 机直接使用的Java类型，这就是虚拟机的类加载机制 
> ⏱ 2023-01-13 13:27:12 ^603120-10-766-791

> 📌 与那些在编译时需要进行连接工作的语言不同， 
> ⏱ 2023-01-13 13:27:34 ^603120-10-821-842

> 📌 Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的 
> ⏱ 2023-01-13 13:27:58 ^603120-10-923-964

> 📌 让一个本地的应用程序可以在运行时从网络或其他地方加载一个二进制流作为程序代码的一部 
> ⏱ 2023-01-13 13:28:25 ^603120-10-1025-1066

> 📌 的OSGi技术，都使用了Java语言运行期类加载的特性。 
> ⏱ 2023-01-13 13:28:41 ^603120-10-1116-1144

> 📌 这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。 
> ⏱ 2023-01-13 13:30:01 ^603120-10-2033-2066

> 📌 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 
> ⏱ 2023-01-13 13:31:08 ^603120-10-2551-2609

> 📌 其父类还没有进行过初始化，则需要先触发其父类的初始化 
> ⏱ 2023-01-13 13:31:15 ^603120-10-2655-2681

> 📌 行为称为对一个类进行主动引用。除此之外，所有引用类的方式 
> ⏱ 2023-01-13 13:32:27 ^603120-10-3020-3048

> 📌 ，可通过-XX:+TraceClassLoading参数观察到此操作会导致子类的加载。 
> ⏱ 2023-01-13 13:34:23 ^603120-10-4071-4114

> 📌 从数据库中读取，这种场景相对少见些，例如有些 
> ⏱ 2023-01-13 21:54:46 ^603120-10-8544-8566

> 📌 ，开发人员可以通过定义自己的类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）。 
> ⏱ 2023-01-13 21:55:22 ^603120-10-8783-8838

> 📌 Java虚拟机将会把数组C标记为与引导类加载器关 
> ⏱ 2023-01-13 21:56:56 ^603120-10-9490-9514

> 📌 Class对象比较特殊，它虽然是对象，但是存放在方法区里面）， 
> ⏱ 2023-01-13 21:58:04 ^603120-10-9955-9986

> 📌 这些变量所使用的内存都将在方法区中进行分配。 
> ⏱ 2023-01-13 22:04:43 ^603120-10-17323-17345

> 📌 而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为123的动作将在初始化阶段才会执行 
> ⏱ 2023-01-13 22:06:36 ^603120-10-17607-17690

> 📌 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。 
> ⏱ 2023-01-13 22:07:25 ^603120-10-18217-18292

> 📌 如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束 
> ⏱ 2023-01-13 22:17:24 ^603120-10-21862-21908

> 📌 虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中第一个被执行的<clinit>()方法的类肯定是java.lang.Object。 
> ⏱ 2023-01-13 22:21:38 ^603120-10-26372-26469

> 📌 、热部署、代码加密等领域大放异彩，成为了Java技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。 
> ⏱ 2023-01-13 22:28:01 ^603120-10-29780-29830

> 📌 启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如代码清单7-9所示为java.lang.ClassLoader.getClassLoader()方法的代码片段 
> ⏱ 2023-01-15 10:42:34 ^603120-10-33294-33417

> 📌 负责加载用户类路径（ClassPath） 
> ⏱ 2023-01-15 10:44:12 ^603120-10-34920-34940

> 📌 这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。 
> ⏱ 2023-01-15 10:45:35 ^603120-10-35481-35554

> 📌 因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 
> ⏱ 2023-01-15 10:46:11 ^603120-10-35782-35864

> 📌 因此Object类在程序的各种类加载器环境中都是同一个类 
> ⏱ 2023-01-15 10:46:40 ^603120-10-36032-36060

> 📌 一个称为java. lang.Object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证， 
> ⏱ 2023-01-15 10:47:00 ^603120-10-36101-36185

### 第8章 虚拟机字节码执行引擎

> 📌 ，而仅仅取决于具体的虚拟机实现。 
> ⏱ 2023-01-16 13:14:04 ^603120-11-1736-1752

> 📌 一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息 
> ⏱ 2023-01-16 13:17:45 ^603120-11-3377-3451

> 📌 加入了花括号之后，placeholder的作用域被限制在花括号之内，从代码逻辑上讲，在执行System.gc()的时候，placeholder已经不可能再被访问了 
> ⏱ 2023-01-16 13:21:07 ^603120-11-5805-5886

> 📌 局部变量表中的Slot是否还存有关于placeholder数组对象的引用 
> ⏱ 2023-01-16 13:21:43 ^603120-11-6719-6755

> 📌 placeholder原本所占用的Slot还没有被其他变量所复用， 
> ⏱ 2023-01-16 13:21:55 ^603120-11-6810-6843

> 📌 所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。 
> ⏱ 2023-01-16 13:22:04 ^603120-11-6843-6875

> 📌 手动将其设置为null值（用来代替那句int a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用 
> ⏱ 2023-01-16 13:23:03 ^603120-11-6958-7086

> 📌 如代码清单8-3那样的场景并不多见。更关键的是，从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的， 
> ⏱ 2023-01-16 13:23:43 ^603120-11-7351-7423

> 📌 在经过JIT编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的。 
> ⏱ 2023-01-16 13:24:04 ^603120-11-7556-7595

> 📌 还好编译器能在编译期间就检查到并提示这一点，即便编译能通过或者手动生成字节码的方式制造出下面代码的效果，字节码校验的时候也会被虚拟机发现而导致类加载失败。 
> ⏱ 2023-01-16 18:44:25 ^603120-11-8000-8077

> 📌 化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据 
> ⏱ 2023-01-16 18:46:07 ^603120-11-9126-9194

> 📌 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程 
> ⏱ 2023-01-16 18:49:15 ^603120-11-10533-10568

> 📌 方法正常退出时，调用者的PC计数器的值可以作为返回地址， 
> ⏱ 2023-01-16 18:49:45 ^603120-11-10619-10647

> 📌 要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。 
> ⏱ 2023-01-16 18:49:54 ^603120-11-10677-10706

> 📌 把返回值（如果有的话）压入调用者栈帧的操作数栈中， 
> ⏱ 2023-01-16 18:50:11 ^603120-11-10789-10814

> 📌 调整PC计数器的值以指向方法调用指令后面的一条指令等。 
> ⏱ 2023-01-16 18:50:16 ^603120-11-10814-10841

> 📌 一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（ 
> ⏱ 2023-01-16 18:52:47 ^603120-11-11266-11315

> 📌 在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者 
> ⏱ 2023-01-16 18:54:03 ^603120-11-11728-11779

> 📌 后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析 
> ⏱ 2023-01-16 18:54:26 ^603120-11-11787-11850

> 📌 在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本 
> ⏱ 2023-01-17 13:19:51 ^603120-11-17001-17035

> 📌 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。 
> ⏱ 2023-01-17 13:20:03 ^603120-11-17137-17166

> 📌 另外，编译器虽然能确定出方法的重载版本，但 
> ⏱ 2023-01-17 13:20:24 ^603120-11-17218-17239

> 📌 这时发生了两次自动类型转 
> ⏱ 2023-01-17 13:21:24 ^603120-11-18869-18881

> 📌 这时发生了一次自动装箱，'a'被包装为它的封装类型java.lang.Character 
> ⏱ 2023-01-17 13:21:30 ^603120-11-19175-19219

> 📌 ，除了用做面试题为难求职者以外，在实际工作中几乎不可能有实际用途 
> ⏱ 2023-01-17 13:21:54 ^603120-11-20496-20528

> 📌 虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口 
> ⏱ 2023-01-17 13:28:46 ^603120-11-28288-28366

> 📌 新增加的指令是JDK 7实现“动态类型语言”（Dynamically Typed Language）支持而进行的改进之一，也是为JDK 8可以顺利实现Lambda表达式做技术准备。 
> ⏱ 2023-01-17 13:33:33 ^603120-11-29176-29266

> 📌 什么是动态类型语言[插图]？动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译 
> ⏱ 2023-01-17 18:01:32 ^603120-11-29526-29669

> 📌 ，即使会导致连接时异常的代码放在一条无法执行到的分支路径上，类加载时（Java的连接过程不在编译阶段，而在类加载阶段）也照样会抛出异常。 
> ⏱ 2023-01-17 18:02:51 ^603120-11-30258-30326

> 📌 。“变量无类型而变量值才有类型”这个特点也是动态类型 
> ⏱ 2023-01-17 18:07:03 ^603120-11-31557-31583

> 📌 言的一个重要特征。 
> ⏱ 2023-01-17 18:07:11 ^603120-11-31584-31593

> 📌 动态生成字节码实现具体类型到占位符类型的适配 
> ⏱ 2023-01-17 18:09:10 ^603120-11-32580-32602

> 📌 但Java语言做不到这一点，即没有办法单独地把一个函数作为参数进行传递。普 
> ⏱ 2023-01-17 18:10:20 ^603120-11-33473-33510

> 📌 Java语言也可以拥有类似于函数指针或者委托的方法别名的工具了。 
> ⏱ 2023-01-17 18:10:47 ^603120-11-33720-33752

> 📌 无论obj是何种类型（临时定义的ClassA抑或是实现PrintStream接口的实现类System.out），都可以正确地调用到println()方法。 
> ⏱ 2023-01-17 18:11:02 ^603120-11-33781-33858

> 📌 实际上，方法getPrintlnMH()中模拟了invokevirtual指令的执行过程，只不过它的分派逻辑并非固化在Class文件的字节码上，而是通过一个具体方法来实现。而这个方法本身的返回值（MethodHandle对象），可以视为对最终调用方法的一个“引用” 
> ⏱ 2023-01-17 18:13:33 ^603120-11-35302-35434

> 📌 而MethodHandle是在模拟字节码层次的方法调用 
> ⏱ 2023-01-17 18:14:00 ^603120-11-35968-35995

> 📌 。而后者仅仅包含与执行该方法相关的信息。用通俗的话来讲，Reflection是重量级，而MethodHandle是轻量级。 
> ⏱ 2023-01-17 18:15:09 ^603120-11-36507-36568

> 📌 ，而MethodHandle则设计成可服务于所有Java虚拟机之上的语言，其中也包括Java语言。 
> ⏱ 2023-01-17 18:15:59 ^603120-11-36968-37017

> 📌 每一处含有invokedynamic指令的位置都称做“动态调用点”（Dynamic Call Site），这条指令的第一个参数不再是代表方法符号引用的C 
> ⏱ 2023-01-17 18:22:38 ^603120-11-37583-37659

> 📌 从这个新常量中可以得到3项信息：引导方法（Bootstrap Method，此方法存放在新增的BootstrapMethods属性中）、方法类型（MethodType）和名称。 
> ⏱ 2023-01-17 18:22:51 ^603120-11-37729-37817

> 📌 这个代表真正要执行的目标方法调用。根据 
> ⏱ 2023-01-17 18:22:58 ^603120-11-37864-37883

> 📌 Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。 
> ⏱ 2023-01-17 18:39:25 ^603120-11-46414-46476

> 📌 这些指令依赖寄存器进行工作。那么，基于栈的指令集与基于寄存 
> ⏱ 2023-01-17 18:39:59 ^603120-11-46965-46994

> 📌 了解了基于栈的指令集与基于寄存器的指令集的区别后，读者可能会有进一步的疑问，这两套指令集谁更好一些呢？ 
> ⏱ 2023-01-17 18:40:27 ^603120-11-47448-47499

> 📌 基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供[插图]，程序直接依赖这些硬件寄存器则不可避免地要受到硬件的约束。 
> ⏱ 2023-01-17 18:40:43 ^603120-11-47620-47842

> 📌 个32位的通用寄存器。如果使用栈架构的指令集，用户程序不会直接使用这些寄存器，就可以由虚拟机实现来自行决定把一些访问最频繁的数据（程序计数器、栈顶缓存等）放到寄存器中以获取尽量好的性能， 
> ⏱ 2023-01-17 18:41:24 ^603120-11-47914-48007

> 📌 栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。 
> ⏱ 2023-01-17 18:41:45 ^603120-11-48146-48201

> 📌 因为出栈、入栈操作本身就产生了相当多的指令数量 
> ⏱ 2023-01-17 18:41:56 ^603120-11-48272-48295

> 📌 频繁的栈访问也就意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈 
> ⏱ 2023-01-17 18:42:07 ^603120-11-48311-48351

> 📌 由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢 
> ⏱ 2023-01-17 18:42:25 ^603120-11-48415-48451

> 📌 可以直接使用javap命令看看它的字节码指令，如代码清单8-17所示。代码清单8-17 一段简单的 
> ⏱ 2023-01-17 18:42:44 ^603120-11-48928-49029

> 📌 更准确地说，实际情况会和上面描述的概念模型差距非常大，这种差距产生的原因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化 
> ⏱ 2023-01-17 18:45:13 ^603120-11-51311-51374

### 第9章 类加载及执行子系统的案例与实战

> 📌 而是指类库在使用时都要被加载到服务器内存，如果类库不能共享，虚拟机的方法区就会很容易出现过度膨胀的风险。 
> ⏱ 2023-01-17 18:48:19 ^603120-12-1836-1888

> 📌 看一看Tomcat具体是如何规划用户类库结构和类加载器的。在Tomcat目录结构中 
> ⏱ 2023-01-17 18:49:29 ^603120-12-3027-3097

> 📌 会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现 
> ⏱ 2023-01-17 18:51:38 ^603120-12-5013-5056

> 📌 JSP文件的HotSwap功 
> ⏱ 2023-01-17 18:51:41 ^603120-12-5056-5070

> 📌 那么被CommonClassLoader或SharedClassLoader加载的Spring如何访问并不在其加载范围内的用户程序呢？如果读过本书第7章的相关内容，相信读者可以很容易地回答这个问题。 
> ⏱ 2023-01-17 18:52:44 ^603120-12-5800-5899

> 📌 先不必去想诸如Javassist、CGLib、ASM之类的字节码类库， 
> ⏱ 2023-01-18 17:06:32 ^603120-12-11518-11553

> 📌 如Web服务器中的JSP编译器，编译时植入的AOP框架，还有很常用的动态代理技术， 
> ⏱ 2023-01-18 16:47:53 ^603120-12-11856-11897

> 📌 跟踪这个方法的源码，可以看到程序进行了验证、优化、缓存、同步、生成字节码、显式类加载等操作，前面的步骤并不是我们关注的重点，而最后它调用了sun.misc. ProxyGenerator.generateProxyClass()方法来完成生成字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码 
> ⏱ 2023-01-18 16:51:22 ^603120-12-13796-13947

> 📌 如果有要大量操作字节码的需求，还是使用封装好的字节码类库比较合适。如果读者对动态代理的字节码拼装过程很感兴趣， 
> ⏱ 2023-01-18 16:54:39 ^603120-12-16508-16563

> 📌 注解等的反射操作。了解了Retrotranslator这种逆向移植工具可以做什么以后， 
> ⏱ 2023-01-18 16:56:35 ^603120-12-17712-17755

> 📌 一个数组来完成参数传递；泛型的信息则在编译阶段就已经擦除掉了（但是在元数据中还保留着），相应的地方被编译器自动插入了类型转换代码。 
> ⏱ 2023-01-18 16:57:01 ^603120-12-18146-18211

> 📌 举仅仅是一个继承于java.lang.Enum、自动生成了values()和valueOf()方法的普通Java类而已。 
> ⏱ 2023-01-18 17:00:32 ^603120-12-20203-20263

> 📌 构造函数中指定为加载HotSwapClassLoader类的类加载器作为父类加载器，这一步是实现提交的执行代码可以访问服务端引用类库的关键 
> ⏱ 2023-01-18 17:18:47 ^603120-12-25798-25867

> 📌 常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串， 
> ⏱ 2023-01-18 17:20:55 ^603120-12-25995-26033

> 📌 用输入的符合Class文件格式的byte[]数组替换java.lang.System的符号引用后，使用HotSwapClassLoader加载生成一个Class对象 
> ⏱ 2023-01-18 17:26:57 ^603120-12-32361-32443

> 📌 ，由于每次执行execute()方法都会生成一个新的类加载器实例，因此同一个类可以实现重复加载。然 
> ⏱ 2023-01-18 17:27:19 ^603120-12-32443-32492

## 第四部分 程序编译与代码优化

> 📌 但是Javac做了许多针对Java语言编码过程的优化措施来改善程序员的编码风格和提高编码效 
> ⏱ 2023-01-18 17:36:33 ^603120-13-2092-2137

> 📌 相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖虚拟机的底层改进来支持，可以说，Java中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。 
> ⏱ 2023-01-18 17:36:50 ^603120-13-2139-2252

> 📌 导入了Javac的源码后，就可以运行com.sun.tools.javac.Main的main()方法来执行编译了 
> ⏱ 2023-01-18 17:38:23 ^603120-13-4052-4109

> 📌 语法分析是根据Token序列构造抽象语法树的过程，抽象 
> ⏱ 2023-01-18 17:39:19 ^603120-13-6424-6451

> 📌 阶段产出的抽象语法树由com.sun.tools.javac.tree.JCTree类表示 
> ⏱ 2023-01-18 17:41:24 ^603120-13-6735-6780

> 📌 符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。 
> ⏱ 2023-01-18 17:43:07 ^603120-13-7334-7445

> 📌 这些注解与普通的Java代码一样，是在运行期间发挥作用的 
> ⏱ 2023-01-18 17:43:29 ^603120-13-7753-7781

> 📌 提供了一组插入式注解处理器的标准API在编译期间对注解进行处理， 
> ⏱ 2023-01-18 17:43:46 ^603120-13-7926-7958

> 📌 在这些插件里面，可以读取、修改、添加抽象语法树中 
> ⏱ 2023-01-18 17:43:56 ^603120-13-7976-8000

> 📌 的任意元素 
> ⏱ 2023-01-18 17:44:00 ^603120-13-8000-8005

> 📌 编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止，每一次循环称为一个Round，也就是图10-4中的回环过程。 
> ⏱ 2023-01-18 17:44:26 ^603120-13-8029-8108

> 📌 ，所以通过插入式注解处理器实现的插件在功能上有很大的发挥空间。只要有足够的创意，程序员可以使用插入式注解处理器来实现许多原本只能在编码中完成的事情 
> ⏱ 2023-01-18 17:45:00 ^603120-13-8203-8276

> 📌 由于编译期间进行了常量折叠，所以在代码里面定义“a=1+2”比起直接定义“a=3”，并不会增加程序运行期哪怕仅仅一个CPU指令的运算量。 
> ⏱ 2023-01-18 17:58:16 ^603120-13-9656-9724

> 📌 因此，将局部变量声明为final，对运行期是没有影响的，变量的不变性仅仅由编译器在编译期间保障 
> ⏱ 2023-01-18 17:59:24 ^603120-13-11001-11048

> 📌 这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。 
> ⏱ 2023-01-18 18:16:23 ^603120-13-14011-14040

> 📌 并且在相应的地方插入了强制转型代码， 
> ⏱ 2023-01-18 18:03:35 ^603120-13-14151-14169

> 📌 是因为两个method()方法加入了不同的返回值后才能共存在一个Class文件之中。 
> ⏱ 2023-01-18 18:06:07 ^603120-13-17756-17798

> 📌 致的两个方法就可以共存。 
> ⏱ 2023-01-18 18:06:21 ^603120-13-17912-17924

> 📌 返回值不同，那它们也是可以合法地共存于一个Class文件中的。 
> ⏱ 2023-01-18 18:06:28 ^603120-13-17948-17979

> 📌 擦除后是同一个类型，我们只能添加两个并不需要实际使用到的返回值才能完成重载，这是一种毫无优雅和美感可言的解决方案，并且存在一定语意上的混乱，譬如上面脚注中提到的，必须用Sun JDK 1.6的Javac才能编译成功，其他版本或者ECJ编译器都可能拒绝编译。 
> ⏱ 2023-01-18 18:06:52 ^603120-13-18873-19001

> 📌 仅仅是对方法的Code属性中的字节码进行擦除，实际上元数据中还是保 
> ⏱ 2023-01-18 18:07:17 ^603120-13-19079-19112

> 📌 了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。 
> ⏱ 2023-01-18 18:07:09 ^603120-13-19113-19144

> 📌 鉴于包装类的“==”运算在不遇到 
> ⏱ 2023-01-18 18:10:23 ^603120-13-21541-21557

> 📌 运算的情况下不会自动拆箱 
> ⏱ 2023-01-18 18:10:27 ^603120-13-21559-21571

> 📌 能使用条件为常量的if语句才能达到上述效果 
> ⏱ 2023-01-18 18:12:22 ^603120-13-22614-22635

> 📌 它是Javac编译器在执行注解处理器代码时要调用的过程 
> ⏱ 2023-01-18 18:15:14 ^603120-13-25705-25732

> 📌 ”中获取到此注解处理器所要处理的注解集合 
> ⏱ 2023-01-18 18:15:33 ^603120-13-25760-25780

> 📌 自动为字段生成getter和setter方法的Project Lombok[插图]（根据已有元素生成新的语法树元素）等，读者有兴趣的话可以参考它们官方站点的相关内容。 
> ⏱ 2023-01-18 19:16:13 ^603120-13-37350-37525

### 第11章 晚期（运行期）优化

> 📌 当程序运行环境中内存资源限制较大（如部分嵌入式系统中），可以使用解释执行节约内存，反之可以使用编译执行来提升效率 
> ⏱ 2023-01-18 19:19:59 ^603120-14-2805-2861

> 📌 而编译动作则在后台的编译线程中进行。 
> ⏱ 2023-01-18 22:52:51 ^603120-14-14755-14773

> 📌 最后阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。 
> ⏱ 2023-01-18 22:55:12 ^603120-14-15487-15583

> 📌 因此一般来说，即时编译器产生的本地代码会比Javac产生的字节码更加优秀[插图] 
> ⏱ 2023-01-18 22:57:00 ^603120-14-25260-25297

> 📌 Java语言是动态的类型安全语言，这就意味着需要由虚拟机来确保程序不会违反语言语义或访问非结构化内存。 
> ⏱ 2023-01-18 22:59:17 ^603120-14-39275-39326

> 📌 如实例方法访问时检查空指针、数组元素访问时检查上下界范围、类型转换时检查继承关系等。对于这类程序代码没有明确写出的检查行为，尽管编译器会努力进行优化，但是总体上仍然要消耗不少的运行时 
> ⏱ 2023-01-18 22:59:26 ^603120-14-39354-39445

## 第五部分 高效并发

> 📌 主内存主要对应于Java堆中的对象实例数据部分 
> ⏱ 2023-01-18 23:25:20 ^603120-15-5503-5526

> 📌 应于虚拟机栈中的部分区 
> ⏱ 2023-01-18 23:25:34 ^603120-15-5745-5756

> 📌 它把一个变量的值从主内存传输到线程的工作内存 
> ⏱ 2023-01-18 23:27:15 ^603120-15-7230-7252

> 📌 它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 
> ⏱ 2023-01-18 23:27:33 ^603120-15-7473-7505

> 📌 它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。 
> ⏱ 2023-01-18 23:28:05 ^603120-15-7709-7764

> 📌 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量， 
> ⏱ 2023-01-18 23:29:50 ^603120-15-9597-9652

> 📌 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次 
> ⏱ 2023-01-18 23:30:17 ^603120-15-9860-9909

> 📌 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。 
> ⏱ 2023-01-18 23:31:21 ^603120-15-10105-10177

> 📌 再加上稍后介绍的对volatile的一些特殊规定， 
> ⏱ 2023-01-18 23:31:43 ^603120-15-10655-10680

> 📌 中笔者将介绍这种定义的一个等效判断原则——先行发生原则，用来确定一个访问在并发环境下是否安全。 
> ⏱ 2023-01-18 23:32:07 ^603120-15-10747-10794

> 📌 关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制 
> ⏱ 2023-01-18 23:32:15 ^603120-15-10911-10945

> 📌 遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步。 
> ⏱ 2023-01-18 23:32:53 ^603120-15-10982-11022

> 📌 当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 
> ⏱ 2023-01-18 23:43:02 ^603120-15-11230-11320

> 📌 变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见 
> ⏱ 2023-01-18 23:43:17 ^603120-15-11335-11427

> 📌 但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题 
> ⏱ 2023-01-18 23:44:09 ^603120-15-11718-11761

> 📌 导致volatile变量 
> ⏱ 2023-01-18 23:44:18 ^603120-15-11781-11793

> 📌 运算在并发下一样是不安全的 
> ⏱ 2023-01-18 23:44:23 ^603120-15-11794-11807

> 📌 volatile关键字保证了race的值在此时是正确的，但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值加大了，而在操作栈顶的值就变成了过期的数据，所以putstatic指令执行后就可 
> ⏱ 2023-01-18 23:46:24 ^603120-15-13230-13339

> 📌 。一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义 
> ⏱ 2023-01-18 23:47:01 ^603120-15-13820-13855

> 📌 地机器码指令，此处使用-XX:+PrintAssembly参数输出反汇编来分析会更加严谨一些 
> ⏱ 2023-01-18 23:47:59 ^603120-15-13881-13927

> 📌 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。[插图]变量不需要与其他的状态变量共同参与不变约束。 
> ⏱ 2023-01-18 23:48:21 ^603120-15-14249-14465

> 📌 当shutdown()方法被调用时，能保证所有线程中执行的doWork()方法都立即停下 
> ⏱ 2023-01-18 23:49:07 ^603120-15-14537-14581

> 📌 普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致 
> ⏱ 2023-01-18 23:52:58 ^603120-15-14949-15018

> 📌 因为在一个线程的方法执行过程中无法感知到这点 
> ⏱ 2023-01-18 23:53:35 ^603120-15-15019-15041

> 📌 多执行了一个“lock addl $0x0，（%esp）”操作，这个操作相当于一个内存屏障（ 
> ⏱ 2023-01-18 23:59:57 ^603120-15-17850-17896

> 📌 因此，lock addl $0x0，（%esp）指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。 
> ⏱ 2023-01-18 23:58:56 ^603120-15-18740-18819

> 📌 volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 
> ⏱ 2023-01-19 00:06:11 ^603120-15-19081-19161

> 📌 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行， 
> ⏱ 2023-01-19 00:08:19 ^603120-15-20754-20799

> 📌 long和double的非原子性协定 
> ⏱ 2023-01-19 00:08:32 ^603120-15-20860-20878

> 📌 那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。 
> ⏱ 2023-01-19 00:08:49 ^603120-15-21017-21060

> 📌 但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现 
> ⏱ 2023-01-19 00:09:26 ^603120-15-21172-21213

> 📌 的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。 
> ⏱ 2023-01-19 00:09:40 ^603120-15-21245-21306

> 📌 我们大致可以认为基本数据类型的访问读写是具备原子性的 
> ⏱ 2023-01-19 10:33:57 ^603120-15-21644-21670

> 📌 就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。 
> ⏱ 2023-01-19 10:34:04 ^603120-15-21673-21730

> 📌 这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性 
> ⏱ 2023-01-19 10:35:05 ^603120-15-21902-21970

> 📌 volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 
> ⏱ 2023-01-19 10:35:49 ^603120-15-22217-22261

> 📌 除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中 
> ⏱ 2023-01-19 10:36:12 ^603120-15-22334-22427

> 📌 被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象 
> ⏱ 2023-01-19 10:36:34 ^603120-15-22469-22560

> 📌 如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。 
> ⏱ 2023-01-19 10:37:19 ^603120-15-23033-23170

> 📌 Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性 
> ⏱ 2023-01-19 10:37:43 ^603120-15-23199-23247

> 📌 一个变量在同一个时刻只允许一条线程对其进行lock操作 
> ⏱ 2023-01-19 10:38:50 ^603120-15-23293-23320

> 📌 这条规则决定了持有同一个锁的两个同步块只能串行地进入。 
> ⏱ 2023-01-19 10:39:28 ^603120-15-23329-23356

> 📌 Java语言中有一个“先行发生”（happens-before）的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。 
> ⏱ 2023-01-19 10:40:58 ^603120-15-23771-23889

> 📌 先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值、发送了消息、调用了方法等。 
> ⏱ 2023-01-19 10:47:42 ^603120-15-23938-24045

> 📌 。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 
> ⏱ 2023-01-19 10:49:25 ^603120-15-24692-24753

> 📌 在一个线程内， 
> ⏱ 2023-01-19 10:49:36 ^603120-15-24965-24972

> 📌 对一个volatile变量的写操作先行发生于后面对这个变量的读操作， 
> ⏱ 2023-01-19 10:51:04 ^603120-15-25532-25566

> 📌 ：线程中的所有操作都先行发生于对此线程的终止检测 
> ⏱ 2023-01-19 11:09:27 ^603120-15-26046-26070

> 📌 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始 
> ⏱ 2023-01-19 11:10:12 ^603120-15-26636-26678

> 📌 因此我们可以判定尽管线程A在操作时间上先于线程B，但是无法确定线 
> ⏱ 2023-01-19 16:34:04 ^603120-15-27741-27773

> 📌 程B中“getValue()”方法的返回结果，换句话说，这里面的操作不是线程安全的。 
> ⏱ 2023-01-19 16:34:10 ^603120-15-27773-27815

> 📌 把getter/setter方法都定义为synchronized方法，这样就可以套用管程锁定规则； 
> ⏱ 2023-01-19 16:38:05 ^603120-15-27876-27925

> 📌 根据程序次序规则，“int i=1”的操作先行发生于“int j=2”，但是“int j=2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这点。 
> ⏱ 2023-01-19 16:39:07 ^603120-15-28383-28482

> 📌 时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。 
> ⏱ 2023-01-19 16:39:41 ^603120-15-28529-28595

> 📌 一个Native方法往往意味着这个方法没有使用或无法使用平台无关的手段来实现 
> ⏱ 2023-01-19 16:42:43 ^603120-15-29187-29225

> 📌 当然也可能是为了执行效率而使用Native方法，不过，通常最高效率的手段也就是平台相关的手段 
> ⏱ 2023-01-19 16:42:56 ^603120-15-29226-29272

> 📌 但是轻量级进程具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。 
> ⏱ 2023-01-19 17:12:53 ^603120-15-30223-30336

> 📌 诸如“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”这 
> ⏱ 2023-01-19 17:16:08 ^603120-15-31221-31256

> 📌 Java、Ruby等语言都曾经使用过用户线程，最终又都放弃使用它。 
> ⏱ 2023-01-19 17:16:37 ^603120-15-31518-31551

> 📌 而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁， 
> ⏱ 2023-01-19 17:17:37 ^603120-15-31787-31820

> 📌 线程的系统调用要通过轻量 
> ⏱ 2023-01-19 17:17:53 ^603120-15-31848-31860

> 📌 线程来完成，大大降低了整个进程被完全阻塞的风险 
> ⏱ 2023-01-19 17:17:57 ^603120-15-31861-31884

> 📌 Java线程在JDK 1.2之前，是基于称为“绿色线程”（Green Threads）的用户线程实现的，而在JDK 1.2中，线程模型替换为基于操作系统原生线程模型来实现。 
> ⏱ 2023-01-19 17:19:19 ^603120-15-32368-32454

> 📌 对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线程模型就是一对一的[插图]。 
> ⏱ 2023-01-19 17:19:57 ^603120-15-32637-32872

> 📌 如果使用协同式调度的多线程系统 
> ⏱ 2023-01-19 17:20:37 ^603120-15-33376-33391

> 📌 主动通知系统切换到另外一个线程上。 
> ⏱ 2023-01-19 17:20:42 ^603120-15-33424-33441

> 📌 Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread. MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行 
> ⏱ 2023-01-19 17:21:55 ^603120-15-34237-34338

> 📌 线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应 
> ⏱ 2023-01-19 17:22:07 ^603120-15-34371-34474

> 📌 。因此，我们不能在程序中通过优先级来完全准确地判断一组状态都为Ready的线程将会先执行哪一个。 
> ⏱ 2023-01-19 17:22:57 ^603120-15-35172-35220

> 📌 也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时 
> ⏱ 2023-01-19 17:23:51 ^603120-15-35765-35803

> 📌 处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态： 
> ⏱ 2023-01-19 17:23:34 ^603120-15-35979-36036

> 📌 不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态： 
> ⏱ 2023-01-19 17:24:12 ^603120-15-36406-36458

> 📌 阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁 
> ⏱ 2023-01-19 17:25:11 ^603120-15-36909-36944

> 📌 在程序等待进入同步区域的时候，线程将进入这种状态。 
> ⏱ 2023-01-19 17:25:06 ^603120-15-36995-37020

### 第13章 线程安全与锁优化

> 📌 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的 
> ⏱ 2023-01-19 17:30:51 ^603120-16-1452-1552

> 📌 不可变”带来的安全性是最简单和最纯粹的。 
> ⏱ 2023-01-19 19:22:40 ^603120-16-2667-2687

> 📌 如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响才行 
> ⏱ 2023-01-19 19:23:19 ^603120-16-2773-2810

> 📌 中带有状态的变量都声明为final，这样在构造函数结束之后，它就是不可变的， 
> ⏱ 2023-01-19 19:23:43 ^603120-16-2991-3029

> 📌 它需要保证对这个对象单独的操作是线程安全 
> ⏱ 2023-01-19 19:33:37 ^603120-16-6840-6860

> 📌 Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此， 
> ⏱ 2023-01-19 21:40:24 ^603120-16-8362-8420

> 📌 互斥是因，同步是 
> ⏱ 2023-01-19 21:40:38 ^603120-16-8428-8436

> 📌 那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。 
> ⏱ 2023-01-19 21:42:01 ^603120-16-8682-8736

> 📌 ，Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级（Heavyweight）的操作 
> ⏱ 2023-01-20 15:38:03 ^603120-16-9092-9296

> 📌 相比synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。 
> ⏱ 2023-01-20 15:39:06 ^603120-16-9625-9696

> 📌 ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。 
> ⏱ 2023-01-20 15:39:51 ^603120-16-10183-10230

> 📌 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步 
> ⏱ 2023-01-20 15:41:37 ^603120-16-12076-12119

> 📌 基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。 
> ⏱ 2023-01-20 15:45:30 ^603120-16-12321-12494

> 📌 即时编译出来的结果就是一条平台相关的处理器CAS指令， 
> ⏱ 2023-01-20 15:48:09 ^603120-16-14131-14158

> 📌 ，如J.U.C包里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作 
> ⏱ 2023-01-20 15:48:54 ^603120-16-14461-14534

> 📌 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。 
> ⏱ 2023-01-20 15:51:40 ^603120-16-16616-16724

> 📌 比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改 
> ⏱ 2023-01-20 15:52:19 ^603120-16-16832-16876

> 📌 可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。 
> ⏱ 2023-01-20 15:53:09 ^603120-16-17274-17335

> 📌 不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法 
> ⏱ 2023-01-20 15:53:27 ^603120-16-17380-17424

> 📌 如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。 
> ⏱ 2023-01-20 15:53:45 ^603120-16-17453-17519

> 📌 如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问 
> ⏱ 2023-01-20 15:54:51 ^603120-16-17654-17710

> 📌 其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。 
> ⏱ 2023-01-20 15:55:26 ^603120-16-17805-17915

> 📌 挂起线程和恢复线程的操作都需要转入内核态中完 
> ⏱ 2023-01-20 15:57:45 ^603120-16-18875-18897

> 📌 堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行 
> ⏱ 2023-01-20 16:02:44 ^603120-16-19966-20029

> 📌 减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 
> ⏱ 2023-01-20 16:05:16 ^603120-16-22108-22134

> 📌 另外一部分用于存储指向方法区对象类型数据的指 
> ⏱ 2023-01-20 16:05:48 ^603120-16-22393-22415

> 📌 然后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向L 
> ⏱ 2023-01-20 16:07:28 ^603120-16-23234-23269

> 📌 Record的指针 
> ⏱ 2023-01-20 16:07:34 ^603120-16-23273-23282

> 📌 虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。 
> ⏱ 2023-01-20 16:12:02 ^603120-16-24117-24206

> 📌 那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针 
> ⏱ 2023-01-20 16:12:41 ^603120-16-24223-24286

> 📌 如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了。如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。 
> ⏱ 2023-01-20 16:13:43 ^603120-16-24369-24509

> 📌 轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。 
> ⏱ 2023-01-20 16:14:08 ^603120-16-24538-24680

> 📌 如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。 
> ⏱ 2023-01-20 16:15:39 ^603120-16-24839-24909

# 读书笔记

# 本书评论
