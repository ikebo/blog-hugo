---
doc_type: weread-highlights-reviews
bookId: "3001310764"
author: 【英】马丁·福勒
cover: https://cdn.weread.qq.com/outpic/764/3001310764.jpg
reviewCount: 0
noteCount: 32
readingStatus: 在读
progress: 99%
totalReadDay: 5
readingTime: 1小时8分钟
readingDate: 2021-11-22
isbn: 9787115508652
lastReadDate: 2021-12-13

---
# 元数据
> [!abstract] 重构 改善既有代码的设计（第2版 平装版）(异步图书出品)
> - ![ 重构 改善既有代码的设计（第2版 平装版）(异步图书出品)|200](https://cdn.weread.qq.com/outpic/764/3001310764.jpg)
> - 书名： 重构 改善既有代码的设计（第2版 平装版）(异步图书出品)
> - 作者： 【英】马丁·福勒
> - 简介： 本书是经典著作《重构》出版20年后的更新版。书中清晰揭示了重构的过程，解释了重构的原理和实践方式，并给出了何时以及何地应该开始挖掘代码以求改善。书中给出了60多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。本书提出的重构准则将帮助开发人员一次一小步地修改代码，从而减少了开发过程中的风险。 本书适合软件开发人员、项目管理人员等阅读，也可作为高等院校计算机及相关专业师生的参考读物。
> - 出版时间 2019-05-01
> - ISBN： 9787115508652
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/2ed32e60811e3a304g014c02

# 高亮划线

## 前言

> 📌 重构的每个步骤都很简单，甚至显得有些过于简单：只需要把某个字段从一个类移到另一个类，把某些代码从一个函数拉出来构成另一个函数，或是在继承体系中把某些代码推上推下就行了。但是，聚沙成塔，这些小小的修改累积起来就可以根本改善设计质量 
> ⏱ 2021-12-10 12:55:33 ^3001310764-9-2114-2228

> 📌 我发现设计不是在一开始完成的，而是在整个开发过程中逐渐浮现出来。 
> ⏱ 2021-12-10 12:55:48 ^3001310764-9-2292-2324

> 📌 在系统构筑过程中，我学会了如何不断改进设计。这个“构筑-设计”的反复互动，可以让一个程序在开发过程中持续保有良好的设计。 
> ⏱ 2021-12-10 12:55:58 ^3001310764-9-2324-2384

## 第1章 重构，第一个示例

> 📌 示例之所以可以拯救我于太虚之中，因为它让我看见事情在真正进行 
> ⏱ 2021-12-11 08:39:24 ^3001310764-11-486-516

> 📌 但如果程序要保存很长时间，那么重复的逻辑就会造成潜在的威胁。 
> ⏱ 2021-12-11 09:00:00 ^3001310764-11-4908-4938

> 📌 。毕竟，需求通常不来则已，一来便会接踵而至。 
> ⏱ 2021-12-11 09:00:41 ^3001310764-11-5139-5161

> 📌 我再强调一次，是需求的变化使重构变得必要。如果一段代码能正常工作，并且不会再被修改，那么完全可以不去重构它。 
> ⏱ 2021-12-11 09:01:24 ^3001310764-11-5374-5428

> 📌 我得确保即将修改的代 
> ⏱ 2021-12-11 09:07:17 ^3001310764-11-5580-5590

> 📌 码拥有一组可靠的测试。这些测试必不可少，因为尽管遵循重构手法可以使我避免绝大多数引入bug的情形，但我毕竟是人，毕竟有可能犯错。程序越大，我的修改不小心破坏其他代码的可能性就越大——在数字时代，软件的名字就是脆弱。 
> ⏱ 2021-12-11 09:07:24 ^3001310764-11-5590-5697

> 📌 重构前，先检查自己是否有一套可靠的测试集。这些测试必须有自我检验能力。 
> ⏱ 2021-12-12 17:59:05 ^3001310764-11-6297-6386

> 📌 进行重构时，我需要依赖测试 
> ⏱ 2021-12-12 17:59:26 ^3001310764-11-6426-6439

> 📌 尽管编写测试需要花费时间，但却为我节省下可观的调试时间。构筑测试体系对重构来说实在太重要了，因此我将用第4章一整章的笔墨来详细讨论它。 
> ⏱ 2021-12-12 17:59:57 ^3001310764-11-6545-6612

> 📌 这样当我回头看时，代码就能告诉我它在干什么，我不需要重新思考一遍。 
> ⏱ 2021-12-12 18:02:12 ^3001310764-11-8278-8311

> 📌 首先，我需要检查一下，如果我将这块代码提炼到自己的一个函数里，有哪些变量会离开原本的作用域 
> ⏱ 2021-12-12 18:02:44 ^3001310764-11-8572-8617

> 📌 前两个变量会被提炼后的函数使用，但不会被修改，那么我就可以将它们以参数方式传递进来。我更关心那些会被修改的变量 
> ⏱ 2021-12-12 18:03:56 ^3001310764-11-8690-8745

> 📌 无论每次重构多么简单，养成重构后即运行测试的习惯非常重要 
> ⏱ 2021-12-13 09:17:19 ^3001310764-11-10703-10731

> 📌 小步修改，每次修改后就运行测试。 
> ⏱ 2021-12-13 09:17:36 ^3001310764-11-10822-10838

> 📌 如果我改动了太多东西，犯错时就可能陷入麻烦的调试，并为此耗费大把时间。小步修改，以及它带来的频繁反馈，正是防止混乱的关键。 
> ⏱ 2021-12-13 09:17:56 ^3001310764-11-10838-10899

> 📌 重构技术就是以微小的步伐修改程序。 
> ⏱ 2021-12-13 09:18:43 ^3001310764-11-11428-11445

> 📌 傻瓜都能写出计算机可以理解的代码。唯有能写出人类容易理解的代码的，才是优秀的程序员。 
> ⏱ 2021-12-13 09:21:29 ^3001310764-11-13732-13774

> 📌 这里我要使用的重构手法是以查询取代临时变量 
> ⏱ 2021-12-13 09:22:45 ^3001310764-11-14395-14469

> 📌 移除局部变量的好处就是做提炼时会简单得多， 
> ⏱ 2021-12-13 09:24:55 ^3001310764-11-19663-19684

> 📌 因为需要操心的局部作用域变少了。实际上，在做任何提炼前，我一般都会先移除局部变量 
> ⏱ 2021-12-13 09:25:06 ^3001310764-11-19684-19724

> 📌 。它们只在对其进行处理的代码块中有用，因此临时变量实质上是鼓励你写长而复杂的函数 
> ⏱ 2021-12-13 09:28:59 ^3001310764-11-24729-24769

> 📌 但大多数时候，重复一次这样的循环对性能的影响都可忽略不计。 
> ⏱ 2021-12-13 11:18:34 ^3001310764-11-30890-30919

> 📌 。在聪明的编译器、现代的缓存技术面前，我们很多直觉都是不准确的 
> ⏱ 2021-12-13 11:18:53 ^3001310764-11-31000-31031

> 📌 软件的性能通常只与代码的一小部分相关，改变其他的部分往往对总体性能贡献甚微 
> ⏱ 2021-12-13 11:19:03 ^3001310764-11-31032-31069

> 📌 整个过程一共有4步，每一步都伴随着一次编译、测试以及向本地代码库的提交： 
> ⏱ 2021-12-13 11:19:55 ^3001310764-11-31419-31455

> 📌 。特别是与复杂代码打交道时，细小的步子是快速前进的关键。 
> ⏱ 2021-12-13 11:20:42 ^3001310764-11-32013-32041

> 📌 我总是尽量保持数据不可变（immutable）——可变的状态会很快变成烫手的山芋。 
> ⏱ 2021-12-13 12:40:18 ^3001310764-11-41281-41322

> 📌 编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。 
> ⏱ 2021-12-13 12:42:33 ^3001310764-11-52956-52988

> 📌 我的观点则与营地法则无异：保证离开时的代码库一定比你来时更加健康。完美的境界很难达到，但应该时时都勤加拂拭。 
> ⏱ 2021-12-13 12:43:08 ^3001310764-11-53122-53176

# 读书笔记

# 本书评论
