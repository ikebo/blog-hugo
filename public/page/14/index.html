<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.104.0" /><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ike&#39;Log</title>

<meta name="description" content="Egbert Ke&#39;s Blog">
<meta name="author" content="Egbert Ke">
<link rel="canonical" href="https://ikebo.cc/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7140587df96a2b1a49eb723fa7063dc0c641a6cb638f3140e8d3beb4deae4f5c.css" integrity="sha256-cUBYfflqKxpJ63I/pwY9wMZBpstjjzFA6NO&#43;tN6uT1w=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ikebo.cc/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ikebo.cc/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ikebo.cc/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ikebo.cc/apple-touch-icon.png">
<link rel="mask-icon" href="https://ikebo.cc/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://ikebo.cc/index.xml">
<link rel="alternate" type="application/json" href="https://ikebo.cc/index.json">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Ike&#39;Log" />
<meta property="og:description" content="Egbert Ke&#39;s Blog" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ikebo.cc/" /><meta property="og:image" content="https://ikebo.cc/papermod-cover.png"/>

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ikebo.cc/papermod-cover.png"/>

<meta name="twitter:title" content="Ike&#39;Log"/>
<meta name="twitter:description" content="Egbert Ke&#39;s Blog"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Ike'Log",
  "url": "https://ikebo.cc/",
  "description": "Egbert Ke\u0026#39;s Blog",
  "thumbnailUrl": "https://ikebo.cc/favicon.ico",
  "sameAs": [
      "index.xml", "https://github.com/ikebo", "https://blog.csdn.net/k_runtu", "https://ko-fi.com/ikebo"
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ikebo.cc/" accesskey="h" title="Ike&#39;Log (Alt + H)">Ike&#39;Log</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://ikebo.cc/" title="Posts">
                    <span class="active">Posts</span>
                </a>
            </li>
            <li>
                <a href="https://ikebo.cc/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://ikebo.cc/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://ikebo.cc/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2>WSGI的理解
    </h2>
  </header>
  <div class="entry-content">
    <p>WSGI(Web Server Gateway Interface)是描述Python应用和服务器之间标准接口的协议。若应用开发者和服务器开发者都实现这个协议，则双方都只需要专注自己所需要开发的功能，而不用考虑应用／服务器兼容的问题。
目前WSGI协议已经得到广泛实现, WSGI应用/框架有flask, django等，WSGI服务器有uWSGI(其实现的uwsgi协议是传输协议，主要用于与反向代理的通信), gunicorn等。
WSGI在PEP333中发布，主要内容为1：
WSGI application are callable python objects (functions or classes with a call method that are passed two arguments: a WSGI environment as first argument and a function that starts the response. the application has to start a response using the function provided and return an iterable &gt; where each yielded item means writing and flushing. The WSGI environment is like a CGI environment just with some additional keys that are either provided by the server or a middleware....</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-04 00:00:00 +0000 UTC'>July 4, 2019</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Egbert Ke</footer>
  <a class="entry-link" aria-label="post link to WSGI的理解" href="https://ikebo.cc/post/migrate/wsgi%E7%9A%84%E7%90%86%E8%A7%A3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>epoll/kqueue 的理解
    </h2>
  </header>
  <div class="entry-content">
    <p>tornado以异步IO的方式提高性能，对于有多条长连接的情况比较适合，比如聊天室。同步／异步，阻塞／非阻塞这两对概念比较难理解。epoll/kqueue是Linux内核用于异步IO的机制。
阻塞：比如等快递，假设快递没到你啥也干不了，这时你还不如去睡觉，因为你知道快递员到时候会打电话叫你。这种因为等快递而啥也干不了的状态就是阻塞，好处就是你可以轻松地去睡觉。对应到操作系统就是阻塞的线程一直在等待，也就是说这个线程只能同时处理这一个IO流，如果想要同时处理多个流，要没多进程，要么多线程，但是两者的性能都不高。因为线程被阻塞所以并不在系统的调度队列中，所以资源消耗很少。
非阻塞忙轮询：这就相当于你每隔一段时间就跟打电话给快递员问他快递到了没。对应到操作系统中，这种方式同时处理多个IO流，但是比较消耗资源，因为做了很多无效的遍历。
while true { for i in stream[]; { if i has data read until unavailable } } 为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用，当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。 假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方。
假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内&gt; 核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为“缓冲区非空”。 但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留&gt; 在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程 A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。 假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来 了，继续写数据了，我们把这个事件叫做“缓冲区非满”。 也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。 这四个情形涵盖了四个I/O事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（说的内核缓冲区）。这四个I/O事件是进行阻塞同步的根本。 那有没有一种机制，既可以同时处理多个IO流，又可以避免忙轮询呢？epoll/kqueue就是干这个的。阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象。
为了避免CPU空转，可以引进了一个代理（select）。这个代理可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流。
while true { select(streams[]) for i in streams[] { if i has data read until unavailable } } 如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。
但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。
epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll之会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了O(k)，k为产生I/O事件的流的个数，也有认为O(1)）
while true { active_stream[] = epoll_wait(epollfd) for i in active_stream[] { read or write till unavailable } } 部分整合自: 知乎</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-03 00:00:00 +0000 UTC'>July 3, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Egbert Ke</footer>
  <a class="entry-link" aria-label="post link to epoll/kqueue 的理解" href="https://ikebo.cc/post/migrate/epoll-%E5%92%8C-kqueue%E7%9A%84%E7%90%86%E8%A7%A3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>tmux简单记录
    </h2>
  </header>
  <div class="entry-content">
    <p>Session
新建session
tmux new -s sessionname 退出当前session
prefix &#43; d 进入session
tmux at -t sessionname 关闭session
tmux kill-session -t sessionname 列出所有session
tmux ls Window 新建window
prefix &#43; c 切换window:
prefix &#43; p/n 列出所有window:
prefix &#43; w 删除当前window:
prefix &#43; &amp; Pane 切分pane
prefix &#43; &#34;/% 切换pane:
prefix &#43; o 删除当前pane:
prefix &#43; x 重启pane:
prefix &#43; : 输入 respawn-pane -k，然后 Enter
prefix 默认为ctrl &#43; b, 可自定义</p>
  </div>
  <footer class="entry-footer"><span title='2019-07-02 00:00:00 +0000 UTC'>July 2, 2019</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Egbert Ke</footer>
  <a class="entry-link" aria-label="post link to tmux简单记录" href="https://ikebo.cc/post/migrate/tmux%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>
    </h2>
  </header>
  <div class="entry-content">
    <p>什么是Tun/Tap 在计算机网络中，TUN与TAP是操作系统内核中的虚拟网络设备。不同于普通靠硬件网路板卡实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。
TAP等同于一个以太网设备，它操作第二层数据包如以太网数据帧。TUN模拟了网络层设备，操作第三层数据包比如IP数据封包。
操作系统通过TUN/TAP设备向绑定该设备的用户空间的程序发送数据，反之，用户空间的程序也可以像操作硬件网络设备那样，通过TUN/TAP设备发送数据。在后种情况下，TUN/TAP设备向操作系统的网络栈投递（或“注入”）数据包，从而模拟从外部接受数据的过程。
应用程序如何操作Tun/Tap Linux Tun/Tap驱动程序为应用程序提供了两种交互方式：虚拟网络接口和字符设备/dev/net/tun。写入字符设备/dev/net/tun的数据会发送到虚拟网络接口中；发送到虚拟网络接口中的数据也会出现在该字符设备上。
应用程序可以通过标准的Socket API向Tun/Tap接口发送IP数据包，就好像对一个真实的网卡进行操作一样。除了应用程序以外，操作系统也会根据TCP/IP协议栈的处理向Tun/Tap接口发送IP数据包或者以太网数据包，例如ARP或者ICMP数据包。Tun/Tap驱动程序会将Tun/Tap接口收到的数据包原样写入到/dev/net/tun字符设备上，处理Tun/Tap数据的应用程序如VPN程序可以从该设备上读取到数据包，以进行相应处理。
应用程序也可以通过/dev/net/tun字符设备写入数据包，这种情况下该字符设备上写入的数据包会被发送到Tun/Tap虚拟接口上，进入操作系统的TCP/IP协议栈进行相应处理，就像从物理网卡进入操作系统的数据一样。
Tun虚拟设备和物理网卡的区别是Tun虚拟设备是IP层设备，从/dev/net/tun字符设备上读取的是IP数据包，写入的也只能是IP数据包，因此不能进行二层操作，如发送ARP请求和以太网广播。与之相对的是，Tap虚拟设备是以太网设备，处理的是二层以太网数据帧，从/dev/net/tun字符设备上读取的是以太网数据帧，写入的也只能是以太网数据帧。从这点来看，Tap虚拟设备和真实的物理网卡的能力更接近。
下图描述了Tap/Tun的工作原理： 使用Tun/Tap创建点对点隧道 通过应用程序从/dev/net/tun字符设备中读取或者写入数据看上去并没有太大用处，但通过将Tun/Tap结合物理网络设备使用,我们可以创建一个点对点的隧道。如下图所示，左边主机上应用程序发送到Tun虚拟设备上的IP数据包被VPN程序通过字符设备接收，然后再通过一个TCP或者UDP隧道发送到右端的VPN服务器上，VPN服务器将隧道负载中的原始IP数据包写入字符设备，这些IP包就会出现在右侧的Tun虚拟设备上，最后通过操作系统协议栈和socket接口发送到右侧的应用程序上。
上图中的隧道也可以采用Tap虚拟设备实现。使用Tap的话，隧道的负载将是以太数据帧而不是IP数据包，而且还会传递ARP等广播数据包。 使用Tun/Tap隧道绕过防火墙 结合路由规则和IPTables规则，可以将VPN服务器端的主机作为连接外部网络的网关，以绕过防火墙对客户端的一些外部网络访问限制。如下图所示，防火墙规则允许客户端访问主机IP2，而禁止访问其他Internet上的节点。通过采用Tun隧道，从防火墙角度只能看到被封装后的数据包，因此防火墙认为客户端只是在访问IP2，会对数据进行放行。而VPN服务端在解包得到真实的访问目的后，会通过路由规则和IPTables规则将请求转发到真正的访问目的地上，然后再将真实目的地的响应IP数据包封装进隧道后原路返回给客户端，从而达到绕过防火墙限制的目的。 使用Tap隧道桥接两个远程站点 如下图所示，可以使用tap建立二层隧道将两个远程站点桥接起来，组成一个局域网。对于两边站点中的主机来说，访问对方站点的主机和本地站点的主机的方式没有区别，都处于一个局域网192.168.0.0/24中。
VPN主机上有两个物理网卡，其中Eth0用于和对方站点的VPN主机进行通信，建立隧道。Eth1在通过网线连接到以太网交换机的同时也被则加入了Linux Bridge，这相当于用一条网线将Linux Bridge上的一个端口（Eth1）连接到了本地站点的以太网交换机上，Eth1上收到的所有数据包都会被发送到Linux Bridge上，Linux Bridge发给Eth1的数据包也会被发送到以太网交换机上。Linux Bridge上还有一个Tap虚拟网卡，用于VPN程序接收从Linux Bridge上收到的数据包。
假设192.168.0.5发出了一个对192.168.0.3的ARP请求，该ARP请求在网络中经过的路径如下：
192.168.0.5发出ARP请求，询问192.168.0.3的MAC地址。 该ARP请求将被发送到以太网交换机上。 以太网交换机对该请求进行泛洪，发送到其包括Eth1在内的所有端口上。 由于Eth1被加入了VPN主机上的Linux Bridge，因此Linux Bridge收到该ARP请求。 Linux Bridge对该ARP请求进行泛洪，发送到连到其上面的Tap虚拟网卡上。 VPN程序通过/dev/net/tun字符设备读取到该ARP请求，然后封装到TCP/UDP包中，发送到对端站点的VPN主机。 对端站点的VPN程序通过监听TCP/UDP端口接收到封装的ARP请求，将ARP请求通过/dev/net/tun字符设备写入到Tap设备中。 Linux Bridge泛洪，将ARP请求发送往Eth1，由于Eth1连接到了以太网交换机上，以太网交换机接收到了该ARP请求。 以太网交换机进行泛洪，将ARP请求发送给了包括192.168.0.3的所有主机。 192.168.0.3收到了APR请求，判断iP地址和自己相同，对此请求进行响应。 同理，ARP响应包也可以按照该路径返回到图左边包括192.168.0.5在内的站点中。 从站点主机的角度来看，上面图中两个VPN主机之间的远程连接可以看作一条虚拟的网线，这条网线将两个Linux Bridge连接起来。这两个Linux Bridge和两个以太网交换机一起将左右两个站点的主机连接在一起，形成了一个局域网。 参考资料 Universal TUN/TAP device driver Universal TUN/TAP device driver Frequently Asked Question Tun/Tap interface tutorial A simplistic, simple-minded, naive tunnelling program using tun/tap interfaces and TCP </p>
  </div>
  <footer class="entry-footer">1 min&nbsp;·&nbsp;Egbert Ke</footer>
  <a class="entry-link" aria-label="post link to " href="https://ikebo.cc/post/2024/11/linux-tun%E4%B8%8Etap%E4%BB%8B%E7%BB%8D/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://ikebo.cc/page/13/">
      «&nbsp;Prev&nbsp;
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ikebo.cc/">Ike&#39;Log</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
